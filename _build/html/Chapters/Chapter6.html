
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Trial-and-Error Root Finding &#8212; Computational Physics  I (PHYS 3500K)</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.1/css/all.min.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.1/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.1/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.1/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css?v=384b581d" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae" />
  <script src="../_static/vendor/fontawesome/6.5.1/js/all.min.js?digest=8d27b9dea8ad943066ae"></script>

    <script src="../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?v=efea14e4"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js?v=36754332"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'Chapters/Chapter6';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Introduction" href="Chapter7.html" />
    <link rel="prev" title="Introduction" href="Chapter5.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a id="pst-skip-link" class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <header class="bd-header navbar navbar-expand-lg bd-navbar">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
  
  
    <p class="title logo__title">Computational Physics  I (PHYS 3500K)</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Welcome to your Jupyter Book
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="Chapter1.html">Making Computers Obey</a></li>






<li class="toctree-l1"><a class="reference internal" href="Chapter2.html">Computer Number Representations</a></li>

<li class="toctree-l1"><a class="reference internal" href="Chapter3.html">Deterministic Randomness</a></li>


<li class="toctree-l1"><a class="reference internal" href="Chapter4.html">Numerical Differentiation</a></li>



<li class="toctree-l1"><a class="reference internal" href="Chapter5.html">Introduction</a></li>


<li class="toctree-l1 current active"><a class="current reference internal" href="#">Trial-and-Error Root Finding</a></li>


<li class="toctree-l1"><a class="reference internal" href="Chapter7.html">Introduction</a></li>



<li class="toctree-l1"><a class="reference internal" href="Chapter8.html">Introduction</a></li>




<li class="toctree-l1"><a class="reference internal" href="Chapter9.html">Introduction</a></li>





<li class="toctree-l1"><a class="reference internal" href="Chapter10.html">Introduction</a></li>


</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/executablebooks/jupyter-book" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/executablebooks/jupyter-book/issues/new?title=Issue%20on%20page%20%2FChapters/Chapter6.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/Chapters/Chapter6.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Trial-and-Error Root Finding</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#">Trial-and-Error Root Finding</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#introduction">Introduction</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#trial-and-error-roots-via-bisection">Trial-and-error Roots via Bisection</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-6-1-temperature-dependence-of-magnetization">Example 6.1: Temperature Dependence of Magnetization.</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#newton-raphson-searching">Newton-Raphson Searching</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#newton-raphson-with-backtracking">Newton-Raphson with Backtracking</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-6-2-newton-raphson-applied-to-the-temperature-dependence-of-magnetization">Example 6.2: Newton-Raphson applied to the Temperature Dependence of Magnetization.</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#matrix-computing">Matrix Computing</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#why-matrix-computing">Why Matrix Computing?</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#classes-of-matrix-problems">Classes of Matrix Problems</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#math-recap-matrix-multiplication-inverses-and-determinants">Math Recap: Matrix Multiplication, Inverses and Determinants</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-6-3-in-this-problem-we-will-find-the-inverse-of-a-3x3-matrix-analytically-and-show-via-direct-matrix-multiplication-that-it-indeed-gives-back-the-identity-matrix">Example 6.3: In this problem we will find the inverse of a 3x3 matrix <em>analytically</em> and show via direct matrix multiplication that it indeed gives back the identity matrix.</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#math-recap-solving-eigenvalue-problems">Math Recap: Solving Eigenvalue Problems</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-6-4-find-the-eigenvalues-and-eigenvectors-of-the-matrix">Example 6.4: Find the eigenvalues and eigenvectors of the matrix:</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-6-5-given-that-lambda-1-5-is-an-eigenvalue-find-the-remaining-eigenvalues-of-the-matrix">Example 6.5: Given that <span class="math notranslate nohighlight">\(\lambda_1 = 5\)</span> is an eigenvalue, find the remaining eigenvalues of the matrix:</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#practical-matrix-computing">Practical Matrix Computing</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#matrices-in-python-python-lists-numpy-arrays">Matrices in Python: Python Lists, NumPy Arrays</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#python-lists">Python Lists</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#numpy-arrays">NumPy Arrays</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#numpy-s-linalg-package">NumPy’s linalg Package</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-6-6-solve-examples-6-3-to-6-5-numerically">Example 6.6: Solve Examples 6.3 to 6.5 numerically!</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#n-dimensional-newton-raphson">N-Dimensional Newton-Raphson</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#more-matrix-examples">More Matrix Examples</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-6-6-your-model-of-some-physical-system-results-in-n-100-coupled-linear-equations-with-n-unknowns">Example 6.6: Your model of some physical system results in <span class="math notranslate nohighlight">\(N=100\)</span> coupled linear equations with <span class="math notranslate nohighlight">\(N\)</span> unknowns:</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-6-7-dirac-gamma-matrices">Example 6.7: Dirac Gamma Matrices</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#data-fitting">Data Fitting</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#lagrange-interpolation">Lagrange Interpolation</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-6-8-lagrange-interpolation">Example 6.8: Lagrange Interpolation</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#cubic-spline-interpolation">Cubic Spline Interpolation</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-6-9-cubic-spline-interpolation-with-scipy">Example 6.9: Cubic Spline Interpolation with scipy</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#other-scipy-interpolators">Other SciPy Interpolators</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-6-10-global-temperature-load-data-with-pandas-and-interpolate-with-scipy">Example 6.10: Global Temperature: Load data with Pandas and Interpolate with SciPy</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#d-interpolation">2-D Interpolation</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#least-squares-fitting">Least-Squares Fitting</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#linear-regression">Linear Regression</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-6-11-hubble-s-law">Example 6.11: Hubble’s Law</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#quadratic-fits">Quadratic Fits</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nonlinear-fitting">Nonlinear Fitting</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <p><font size="6"> <strong>Chapter 6:  Matrix Computing, Trial-and-Error Searching and Data Fitting.</strong> </font></p>
<section class="tex2jax_ignore mathjax_ignore" id="trial-and-error-root-finding">
<h1>Trial-and-Error Root Finding<a class="headerlink" href="#trial-and-error-root-finding" title="Link to this heading">#</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">#</a></h2>
<p>Trial-and-error may not sound very precise, but it is in fact used to solve problems where analytic solutions do not exist, or are not practical.</p>
<p>In trial-and-error algorithms, decisions on what path to follow are made based on the current values of variables, and the program quites only when it thinks it has solved the problem.</p>
<p>Trial-and-error root finding looks for a value of <span class="math notranslate nohighlight">\(x\)</span> for which:</p>
<p><span class="math notranslate nohighlight">\(f(x) \simeq 0\)</span>.</p>
<p>To put the zero on the right-hand side is conventional, since any equation can be written in this form, e.g.</p>
<p><span class="math notranslate nohighlight">\( 10 \sin (x) = 3x^3 \Rightarrow 10 sin(x) - 3x^3 = 0\)</span>.</p>
<p>Generally, the procedure starts with a <em>guessed</em> value for <span class="math notranslate nohighlight">\(x\)</span>, substitutes that guess into <span class="math notranslate nohighlight">\(f(x)\)</span> (the “trial”), and then see how far the left-hand side is from zero.</p>
<p>The program then changes <span class="math notranslate nohighlight">\(x\)</span> based on the error, and tries out a new guess in <span class="math notranslate nohighlight">\(f(x)\)</span>.</p>
<p>The procedure continues until <span class="math notranslate nohighlight">\(f(x) \simeq 0\)</span> to some desired level of precision, or until the changes in <span class="math notranslate nohighlight">\(x\)</span> are insignificant, or if the search seems endless.</p>
</section>
<section id="trial-and-error-roots-via-bisection">
<h2>Trial-and-error Roots via Bisection<a class="headerlink" href="#trial-and-error-roots-via-bisection" title="Link to this heading">#</a></h2>
<p>The most elementary example of trial-and-error root finding is the <em>bisection algorithm</em>. It is reliable, but slow.</p>
<p>If you know some interval in which <span class="math notranslate nohighlight">\(f(x)\)</span> changes sign, then the bisection algorithm will always converge to the root by finding progressively smaller and smaller intervals within which the zero lies.</p>
<p>The bisection algorithm can be described as follows:</p>
<ul class="simple">
<li><p>Start with two values of <span class="math notranslate nohighlight">\(x\)</span> between which we know a zero occurs. For example, you may determine these by making a graph, or by stepping through different values of <span class="math notranslate nohighlight">\(x\)</span> and looking for a sign change.</p></li>
<li><p>Let’s then say that <span class="math notranslate nohighlight">\(f(x)\)</span> changes sign from <span class="math notranslate nohighlight">\(x_1\)</span> to <span class="math notranslate nohighlight">\(x_2\)</span>, e.g. if <span class="math notranslate nohighlight">\(f(x_1) &lt; 0\)</span> then <span class="math notranslate nohighlight">\(f(x_2) &gt; 0\)</span>. The bisection algorithm chooses a new <span class="math notranslate nohighlight">\(x\)</span> as the bisection of the interval (i.e. the mid point!), and selects as its new interval the half in which the sign change occurs.</p></li>
<li><p>The process continues until the value of <span class="math notranslate nohighlight">\(f(x)\)</span> is less than a predefined level of precision, or until a predefined (large) number of subdivisions occurs.</p></li>
</ul>
<p>Let’s implement the bisection algorith and use it in a concrete example!</p>
<section id="example-6-1-temperature-dependence-of-magnetization">
<h3>Example 6.1: Temperature Dependence of Magnetization.<a class="headerlink" href="#example-6-1-temperature-dependence-of-magnetization" title="Link to this heading">#</a></h3>
<p>The magnetization of <span class="math notranslate nohighlight">\(N\)</span> spin-1/2 particles, each with magnetic moment <span class="math notranslate nohighlight">\(\mu\)</span> at a temperature <span class="math notranslate nohighlight">\(T\)</span>, in an external magnetic field <span class="math notranslate nohighlight">\(B\)</span> is given by:</p>
<p><span class="math notranslate nohighlight">\(m(t) = \tanh\left(\frac{ m(t) }{ t } \right)\)</span>,</p>
<p>where <span class="math notranslate nohighlight">\(m(t)\)</span> is the “reduced” magnetization and <span class="math notranslate nohighlight">\(t\)</span> is the reduced temperature <span class="math notranslate nohighlight">\(t\)</span>.</p>
<p>[For the sake of completeness: <span class="math notranslate nohighlight">\(m(T) = M(T)/(N\mu)\)</span>, with <span class="math notranslate nohighlight">\(M\)</span> being the magnetization, <span class="math notranslate nohighlight">\(t=T/T_c\)</span>, with <span class="math notranslate nohighlight">\(T\)</span> being the temperaturem, and <span class="math notranslate nohighlight">\(T_c = N \mu^2 \lambda / k_B\)</span> the Curie temperature.]</p>
<p>Our goal is to find the reduced magnetization <span class="math notranslate nohighlight">\(m\)</span>, for various reduced temperatures: <span class="math notranslate nohighlight">\(t=0.5, 1.0, 2.0\)</span>. We will use the bisection method to solve the <em>transcendetal</em> equation for <span class="math notranslate nohighlight">\(m(t)\)</span>.</p>
<p>We should start by plotting the function that we wish to find the zero of, to get an indication of the location of the zeros. It will be clear that there are no zeros for some of the values. For those that there will be zeros, let’s find the solution to a precision of <span class="math notranslate nohighlight">\(\mathcal{O}(10^{-10})\)</span>. Let’s also print the number of iterations necessary to achieve this.</p>
</section>
</section>
<section id="newton-raphson-searching">
<h2>Newton-Raphson Searching<a class="headerlink" href="#newton-raphson-searching" title="Link to this heading">#</a></h2>
<p>The Newton-Raphson algorithm finds approximate roots of equations of the same type, <span class="math notranslate nohighlight">\(f(x)=0\)</span>, more quickly than the bisection method.</p>
<p>The algorithm is the equivalent of drawing a straight line <span class="math notranslate nohighlight">\(f(x) \simeq mx + b\)</span>, tangent to the curve at an <span class="math notranslate nohighlight">\(x\)</span> value for which <span class="math notranslate nohighlight">\(f(x) \simeq 0\)</span> and then using the intrercept of the line with the <span class="math notranslate nohighlight">\(x\)</span>-axis at <span class="math notranslate nohighlight">\(x=-b/m\)</span> as an improved guess for the root.</p>
<p>If the curve was in fact a straight line, the answer would be exact. Otherwise it is a good approximation if the guess is close enough to the root for <span class="math notranslate nohighlight">\(f(x)\)</span> to be nearly linear.</p>
<p>The process continues until some set level of precision is reached.</p>
<p>If a guess is in a region where <span class="math notranslate nohighlight">\(f(x)\)</span> is nearly linear, the nthe convergence is much more rapid han for the bisection algorithm.</p>
<p>The formulation of the Newton-Raphson algorithm is as follows:</p>
<ul class="simple">
<li><p>Start with a guess <span class="math notranslate nohighlight">\(x_0\)</span>,</p></li>
<li><p>Find the tangent line to <span class="math notranslate nohighlight">\(f(x)\)</span> at <span class="math notranslate nohighlight">\(x_0\)</span> via:
<span class="math notranslate nohighlight">\(y = f(x_0) + (x-x_0) \left. \frac{ \mathrm{d} f}{\mathrm{d} x} \right|_{x=x_0}\)</span>.</p></li>
<li><p>This line crosses the axis at: <span class="math notranslate nohighlight">\(f(x_0) + (x-x_0) \left. \frac{ \mathrm{d} f}{\mathrm{d} x} \right|_{x=x_0} = 0\)</span>.</p></li>
<li><p>Solving for <span class="math notranslate nohighlight">\(x\)</span>: <span class="math notranslate nohighlight">\(x= x_0 - f(x_0)/\left. \frac{ \mathrm{d} f}{\mathrm{d} x} \right|_{x=x_0}\)</span>. This will be the new guess.</p></li>
<li><p>The preocedure is repeated until some level of precision is reached, or a maximum number of evaluations.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span> <span class="c1"># import matplotlib, a conventional module name is plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Now plot! Don&#39;t forget the different labels! </span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span> <span class="c1"># create the elements required for matplotlib. This creates a figure containing a single axes.</span>

<span class="c1"># set the labels and titles:</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$x$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span> <span class="c1"># set the x label</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$f(x)$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span> <span class="c1"># set the y label. Note that the &#39;r&#39; is necessary to remove the need for double slashes. You can use LaTeX! </span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;The Newton-Raphson Method&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span> <span class="c1"># set the title </span>

<span class="c1"># construct the variable: </span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">3.5</span><span class="p">,</span><span class="mi">350</span><span class="p">)</span>
<span class="c1"># and the function:</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span>

<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;$f(x)$&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
<span class="n">x0</span> <span class="o">=</span> <span class="mf">3.0</span>
<span class="n">y0</span> <span class="o">=</span> <span class="mf">3.0</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span>
<span class="n">x1</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">-</span> <span class="p">(</span><span class="n">x0</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x0</span><span class="p">)</span>
<span class="n">y1</span> <span class="o">=</span> <span class="n">x1</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span>
<span class="n">x2</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">-</span> <span class="p">(</span><span class="n">x1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x1</span><span class="p">)</span>
<span class="n">y2</span> <span class="o">=</span> <span class="n">x2</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span>

<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x0</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span><span class="n">y0</span><span class="o">+</span><span class="mf">0.4</span><span class="p">,</span><span class="s2">&quot;$x_0$&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x1</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span><span class="n">y1</span><span class="o">+</span><span class="mf">0.4</span><span class="p">,</span><span class="s2">&quot;$x_1$&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x2</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span><span class="n">y2</span><span class="o">+</span><span class="mf">0.4</span><span class="p">,</span><span class="s2">&quot;$x_2$&quot;</span><span class="p">)</span>

<span class="n">y</span> <span class="o">=</span> <span class="n">y0</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="o">*</span><span class="n">x0</span>
<span class="n">y2</span> <span class="o">=</span> <span class="n">y1</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="o">*</span><span class="n">x1</span>

<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y2</span><span class="p">,</span><span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># draw horizontal line passing through zero</span>
<span class="n">ax</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="n">xmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="mf">3.2</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>

<span class="c1"># draw first vertical line to indicate x_1:</span>
<span class="n">ax</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="n">y1</span><span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>

<span class="c1"># set the limits:</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">3.2</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># construct the legend:</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper center&#39;</span><span class="p">)</span>  <span class="c1"># Add a legend</span>

<span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span> <span class="c1"># show the grid. </span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span> <span class="c1"># show the plot here</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/0d470445f9c93c49f3b6b784fad15f3f5abacecdfd90ae5a3609a46ec56fddae.png" src="../_images/0d470445f9c93c49f3b6b784fad15f3f5abacecdfd90ae5a3609a46ec56fddae.png" />
</div>
</div>
<p>It’s clear that the Newton-Raphson algorithm requires the evaluation of the derivative of the function at the guess point <span class="math notranslate nohighlight">\(x_0\)</span>, <span class="math notranslate nohighlight">\(\left. \frac{ \mathrm{d} f}{\mathrm{d} x} \right|_{x=x_0}\)</span>.</p>
<p>In many cases you may have an analytic expression for the derivative, and it can be built into the algorithm.</p>
<p>However, it is simpler to use a numerical approximation to the derivative, e.g. using the forward-difference derivative:</p>
<p><span class="math notranslate nohighlight">\(  \frac{ \mathrm{d} f}{\mathrm{d} x} \approx \frac{ f(x+\delta x) - f(x) } { \delta x}\)</span>.</p>
<p>A central-difference derivative can also be used, but it would require additional evaluations of the function.</p>
</section>
<section id="newton-raphson-with-backtracking">
<h2>Newton-Raphson with Backtracking<a class="headerlink" href="#newton-raphson-with-backtracking" title="Link to this heading">#</a></h2>
<p>Potential problems may arise while performing Newton-Raphson searching:</p>
<ul class="simple">
<li><p>The search can take us to an <span class="math notranslate nohighlight">\(x\)</span> value where the function has a local minimum or maximum, i.e.: <span class="math notranslate nohighlight">\(\mathrm{d}f/\mathrm{d} x = 0\)</span>. This would lead to a horizontal tangent and then the next guess would be <span class="math notranslate nohighlight">\(x \rightarrow \infty\)</span>, which is hard to return from!</p></li>
<li><p>The search can fall into an infinite loop surrounding the zero without ever getting there.</p></li>
</ul>
<p>The problem in both cases is that the initial guess is not close enough to a region where the function is approximately linear. This is why a good plot may help produce a good first guess.</p>
<p>When the above occur, you may need to start your initial guess (<span class="math notranslate nohighlight">\(x_0\)</span>) at a different point in an effort not to fall in these traps, or try <em>backtracking</em>.</p>
<p><strong>Backtracking</strong>: in cases where the new guess leads to an <em>increase</em> in the magnitude of the function, i.e. <span class="math notranslate nohighlight">\(|f(x_0 + \Delta x)|^2 &gt; |f(x_0)|^2\)</span>, you can backtrack somewhat and try a smaller step, say <span class="math notranslate nohighlight">\(x_0 + \Delta x / 2\)</span>. If the magnitude still increases, then backtrack some more, say by trying <span class="math notranslate nohighlight">\(x_0 + \Delta x / 4\)</span>, and so on.</p>
<p>An alternative solution: start with a bisection search algorithm and switch to faster Newton-Raphson when you get closer to zero.</p>
<section id="example-6-2-newton-raphson-applied-to-the-temperature-dependence-of-magnetization">
<h3>Example 6.2: Newton-Raphson applied to the Temperature Dependence of Magnetization.<a class="headerlink" href="#example-6-2-newton-raphson-applied-to-the-temperature-dependence-of-magnetization" title="Link to this heading">#</a></h3>
<p>Implement the Newton-Raphson search algorithm to find the root of the Transcendental equation given in Example 6.1 for <span class="math notranslate nohighlight">\(t=0.5\)</span> and a precision of <span class="math notranslate nohighlight">\(\mathcal{O}(10^{-10})\)</span>. Use a central-difference derivative while implementing the algorithm and print the number of iterations.</p>
</section>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="matrix-computing">
<h1>Matrix Computing<a class="headerlink" href="#matrix-computing" title="Link to this heading">#</a></h1>
<section id="why-matrix-computing">
<h2>Why Matrix Computing?<a class="headerlink" href="#why-matrix-computing" title="Link to this heading">#</a></h2>
<p>Physical systems are often modeled by systems of simultaneous equations that can be written in matrix form.</p>
<p>As models are made more realistic, matrices become correspondingly bigger. It is therefore important to use a good linear algebra library.</p>
<p>“Industrial-strength” subroutines for matrix computing can be found in well-established scientific libraries. They can be an order of magnitude or more faster than elementary methods found in linear algebra texts.</p>
<p>These packages are usually designed to minimize the round-off error and they are robust, i.e. they have a high chance of being successful for a broad class of problems.</p>
<p>The question is, when is a matrix large enough to require the use of a library routine? A rule of thumb is: “when you have to wait for the answer!”.</p>
<p>Note that GPUs (Graphics Processing Units) can perform matrix algebra very efficiently, since they can execute many commands in parallel. This requires programming in specific frameworks, but it’s good to keep in mind at this point.</p>
</section>
<section id="classes-of-matrix-problems">
<h2>Classes of Matrix Problems<a class="headerlink" href="#classes-of-matrix-problems" title="Link to this heading">#</a></h2>
<p>The most basic matrix problem: a system of linear equations, e.g.:</p>
<p><span class="math notranslate nohighlight">\(\mathbf{A} \vec{x} = \vec{b}\)</span>,</p>
<p>where <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> is an <span class="math notranslate nohighlight">\(N\times N\)</span> matrix, <span class="math notranslate nohighlight">\(\vec{x}\)</span> is an <em>unknown</em> vector of length <span class="math notranslate nohighlight">\(N\)</span>, and <span class="math notranslate nohighlight">\(\vec{b}\)</span> is a known vector of length <span class="math notranslate nohighlight">\(N\)</span>.</p>
<p>The obvious way to solve this: determine the inverse of <span class="math notranslate nohighlight">\(\mathbf{A}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{A}^{-1}\)</span>, and multiply both sides of the equation by it to obtain <span class="math notranslate nohighlight">\(\vec{x}\)</span>:</p>
<p><span class="math notranslate nohighlight">\( \vec{x} = \mathbf{A}^{-1} \vec{b}\)</span>.</p>
<p>Calculating the inverse of a matrix is a standard in a matrix subroutine library.</p>
<p>A more efficient way to solve the linear equation is by Gaussian elimination or lower-upper (LU) decomposition. Both of these yield <span class="math notranslate nohighlight">\(\vec{x}\)</span> without <span class="math notranslate nohighlight">\(\mathbf{A}\)</span>. (However, sometimes you may want the inverse of a matrix.)</p>
<p>Another form of matrix problems that is frequently encountered is:</p>
<p><span class="math notranslate nohighlight">\(\mathbf{A} \vec{x} = \lambda \vec{x}\)</span>,</p>
<p>with an unknown vector <span class="math notranslate nohighlight">\(\vec{x}\)</span> and an unknown parameter <span class="math notranslate nohighlight">\(\lambda\)</span>. This is an <em>eigenvalue problem</em>. Solutions only exist for certain (if any) values of <span class="math notranslate nohighlight">\(\lambda\)</span>. To find a solution, we can use the identity matrix, <span class="math notranslate nohighlight">\(\mathbf{I}\)</span>, to rewrite the equation as follows:</p>
<p><span class="math notranslate nohighlight">\([\mathbf{A} - \lambda \mathbf{I}]\vec{x} = 0\)</span>.</p>
<p>which yields a non-trivial solution only if the determinant of <span class="math notranslate nohighlight">\([\mathbf{A} - \lambda \mathbf{I}]\)</span> is zero, i.e.:</p>
<p><span class="math notranslate nohighlight">\(\det[\mathbf{A} - \lambda \mathbf{I}] = 0\)</span>.</p>
<p>This is known as the “secular equation”. The values of <span class="math notranslate nohighlight">\(\lambda\)</span> that satisfy this equation are the eigenvalues of the eigenvalue equation.</p>
<p>The traditional way to solve the eigenvalue problem for both eigenvalues and eigenvectors is by <em>diagonalization</em> via a transformation matrix <span class="math notranslate nohighlight">\(\mathbf{U}\)</span>:</p>
<p><span class="math notranslate nohighlight">\(\mathbf{U} \mathbf{A} (\mathbf{U}^{-1} \mathbf{U})\vec{x} = \lambda \mathbf{U} \vec{x}\)</span>,</p>
<p><span class="math notranslate nohighlight">\((\mathbf{U} \mathbf{A} \mathbf{U}^{-1}) \mathbf{U}\vec{x} = \lambda \mathbf{U} \vec{x}\)</span>,</p>
<p>where <span class="math notranslate nohighlight">\(\mathbf{U} \mathbf{A} \mathbf{U}^{-1} \equiv \mathbf{D}\)</span> is a diagonal matrix:</p>
<p><span class="math notranslate nohighlight">\( \mathbf{D} = \mathbf{U} \mathbf{A} \mathbf{U}^{-1} = \left(\begin{array}{ccccc} 
\lambda_1' &amp; 0 &amp; 0 &amp; ... &amp; 0\\
0 &amp; \lambda_2' &amp; 0 &amp; ... &amp; 0\\
0 &amp; 0 &amp; \lambda_3' &amp; ... &amp; 0\\
0 &amp; 0 &amp; 0 &amp; ... &amp; \lambda_N'
\end{array}\right)\)</span>,</p>
<p>whose diagonal entries are the eigenvalues, corresponding to eigenvectors:</p>
<p><span class="math notranslate nohighlight">\(\vec{x}_i = \mathbf{U}^{-1} \hat{\vec{e}}_i\)</span>,</p>
<p>i.e. the eigenvectors are the columns of the matrix <span class="math notranslate nohighlight">\(\mathbf{U}^{-1}\)</span>.</p>
</section>
<section id="math-recap-matrix-multiplication-inverses-and-determinants">
<h2>Math Recap: Matrix Multiplication, Inverses and Determinants<a class="headerlink" href="#math-recap-matrix-multiplication-inverses-and-determinants" title="Link to this heading">#</a></h2>
<p>Matrix Multiplication:</p>
<p>To multiply two matrices <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{B}\)</span>:</p>
<p><span class="math notranslate nohighlight">\( \mathbf{A} =  \left(\begin{array}{ccc} 
a_{00} &amp; a_{01} &amp; a_{02} \\
a_{10} &amp; a_{11} &amp; a_{12} \\
a_{20} &amp; a_{21} &amp; a_{22}
\end{array}\right)\)</span>,</p>
<p><span class="math notranslate nohighlight">\( \mathbf{B} =  \left(\begin{array}{ccc} 
b_{00} &amp; b_{01} &amp; b_{02} \\
b_{10} &amp; b_{11} &amp; b_{12} \\
b_{20} &amp; b_{21} &amp; b_{22}
\end{array}\right)\)</span>,</p>
<p>then:</p>
<p><span class="math notranslate nohighlight">\(\mathbf{A}\mathbf{B} = \left(\begin{array}{ccc} 
a_{00} b_{00} + a_{01}b_{10} + a_{02} b_{20} &amp; a_{00} b_{01} + a_{01}b_{11} + a_{02} b_{21} &amp; a_{00} b_{02} + a_{01}b_{12} + a_{02} b_{22} \\
a_{10} b_{00} + a_{11}b_{10} + a_{12} b_{20} &amp; a_{10} b_{01} + a_{11}b_{11} + a_{12} b_{21} &amp; a_{10} b_{02} + a_{11}b_{12} + a_{12} b_{22} \\
a_{20} b_{00} + a_{21}b_{10} + a_{22} b_{20} &amp; a_{20} b_{01} + a_{21}b_{11} + a_{22} b_{21} &amp; a_{20} b_{02} + a_{21}b_{12} + a_{22} b_{22} \\
\end{array}\right)\)</span>,</p>
<p>[See <a class="reference external" href="https://www.geogebra.org/m/ETHXK756">https://www.geogebra.org/m/ETHXK756</a> for an animation!]</p>
<p>Matrix Determinants:</p>
<p>The determinant of a matrix <span class="math notranslate nohighlight">\( \mathbf{A} =  \left(\begin{array}{ccc} 
a_{00} &amp; a_{01} &amp; a_{02} \\
a_{10} &amp; a_{11} &amp; a_{12} \\
a_{20} &amp; a_{21} &amp; a_{22}
\end{array}\right)\)</span>,</p>
<p>is given by:</p>
<p><span class="math notranslate nohighlight">\(\det[A] = a_{00} (a_{11} a_{22} - a_{21} a_{12}) - a_{01} ( a_{01} a_{22} - a_{20} a_{12} ) - a_{02} ( a_{10} a_{21} - a_{20} a_{11} )\)</span></p>
<p>Matrix Inversion (Cramer’s rule):</p>
<p>To invert the matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> as defined above we first need the determinant and the matrix of cofactors:</p>
<p><span class="math notranslate nohighlight">\(\mathbf{C} = \left(\begin{array}{ccc} 
a_{11} a_{22} - a_{21} a_{12} &amp; a_{20} a_{12} - a_{10} a_{22} &amp; a_{10} a_{21} - a_{20} a_{11} \\
a_{21} a_{02} - a_{01} a_{22} &amp; a_{00} a_{22} - a_{20} a_{02} &amp; a_{20} a_{01} - a_{00} a_{21} \\
a_{01} a_{12} - a_{11} a_{02} &amp; a_{20} a_{02} - a_{00} a_{22} &amp; a_{00} a_{11} - a_{10} a_{01}
\end{array}\right)\)</span>,</p>
<p>and then the inverse is given by:</p>
<p><span class="math notranslate nohighlight">\(\mathbf{A}^{-1} = \frac{1}{det[A]} \mathbf{C}^T\)</span>, where the superscript <span class="math notranslate nohighlight">\(T\)</span> denotes a transposition, i.e. an exchange of rows and columns.</p>
<section id="example-6-3-in-this-problem-we-will-find-the-inverse-of-a-3x3-matrix-analytically-and-show-via-direct-matrix-multiplication-that-it-indeed-gives-back-the-identity-matrix">
<h3>Example 6.3: In this problem we will find the inverse of a 3x3 matrix <em>analytically</em> and show via direct matrix multiplication that it indeed gives back the identity matrix.<a class="headerlink" href="#example-6-3-in-this-problem-we-will-find-the-inverse-of-a-3x3-matrix-analytically-and-show-via-direct-matrix-multiplication-that-it-indeed-gives-back-the-identity-matrix" title="Link to this heading">#</a></h3>
<p>(a) Find the determinant of the matrix:</p>
<p><span class="math notranslate nohighlight">\( \mathbf{A} =  \left(\begin{array}{ccc} 
+4 &amp; -2 &amp; +1 \\
+3 &amp; +6 &amp; -4 \\
+2 &amp; +1 &amp; +8
\end{array}\right)\)</span>.</p>
<p>(b) Find the inverse of <span class="math notranslate nohighlight">\(\mathbf{A}\)</span>.</p>
<p>(c) Check that the inverse indeed satisfies <span class="math notranslate nohighlight">\(\mathbf{A}^{-1} \mathbf{A} = \mathbf{I}\)</span>.</p>
</section>
</section>
<section id="math-recap-solving-eigenvalue-problems">
<h2>Math Recap: Solving Eigenvalue Problems<a class="headerlink" href="#math-recap-solving-eigenvalue-problems" title="Link to this heading">#</a></h2>
<p>To find the eigenvalues of a matrix we first subtract <span class="math notranslate nohighlight">\(\lambda\)</span> from its diagonal, take the determinant and set it to zero. We then solve the resulting characteristic equation.</p>
<p>E.g. for a 2x2 matrix,</p>
<p><span class="math notranslate nohighlight">\( \mathbf{A} =  \left(\begin{array}{cc} 
a_{00} &amp; a_{01} \\
a_{10} &amp; a_{11} \\
\end{array}\right)\)</span>,</p>
<p>the characteristic equation is:</p>
<p><span class="math notranslate nohighlight">\(\det\left(\begin{array}{cc} 
a_{00} - \lambda &amp; a_{01} \\
a_{10} &amp; a_{11} - \lambda \\
\end{array}\right) = 0 \)</span></p>
<p>or:</p>
<p><span class="math notranslate nohighlight">\((a_{00} - \lambda) (a_{11} - \lambda) - a_{01} a_{10} = 0\)</span></p>
<p>To find the eigenvectors, i.e. the vectors that satisfy:</p>
<p><span class="math notranslate nohighlight">\(\mathbf{A} \vec{x}_i = \lambda_i \vec{x}_i\)</span>, where <span class="math notranslate nohighlight">\(\lambda_i\)</span> is the <span class="math notranslate nohighlight">\(i\)</span>-th eigenvalue, we can write:</p>
<p><span class="math notranslate nohighlight">\(\vec{x}_i = \left(\begin{array}{c} 
x_i \\
y_i \\
\end{array}\right) = 0 \)</span></p>
<p>and then operate with <span class="math notranslate nohighlight">\(\mathbf{A} - \lambda_i \mathbf{I}\)</span></p>
<p><span class="math notranslate nohighlight">\(\mathbf{A} -  \lambda_i \mathbf{I} = \left(\begin{array}{cc} 
a_{00} - \lambda_i &amp; a_{01} \\
a_{10} &amp; a_{11} - \lambda_i \\
\end{array}\right) \)</span>:</p>
<p><span class="math notranslate nohighlight">\(\left(\begin{array}{cc} 
a_{00} - \lambda_i &amp; a_{01} \\
a_{10} &amp; a_{11} - \lambda_i \\
\end{array}\right) \left(\begin{array}{c} 
x_i  \\
y_i  \\
\end{array}\right)  = \lambda_i \left(\begin{array}{c} 
x_i  \\
y_i  \\
\end{array}\right) \)</span>, to get:</p>
<p><span class="math notranslate nohighlight">\((a_{00} - \lambda_i) x_i + a_{01} y_i = \lambda_i x_i\)</span></p>
<p>and:</p>
<p><span class="math notranslate nohighlight">\(a_{10} x_i + (a_{11} - \lambda_i) y_i = \lambda_i y_i\)</span>,</p>
<p>allowing us to find relations between <span class="math notranslate nohighlight">\(x_i\)</span> and <span class="math notranslate nohighlight">\(y_i\)</span>, i.e. the components of the <span class="math notranslate nohighlight">\(i\)</span>-th eigenvector. The eigenvectors can then be normalized to unity.</p>
<p>Let’s find the eigenvectors and eigenvalues in a concrete example.</p>
<section id="example-6-4-find-the-eigenvalues-and-eigenvectors-of-the-matrix">
<h3>Example 6.4: Find the eigenvalues and eigenvectors of the matrix:<a class="headerlink" href="#example-6-4-find-the-eigenvalues-and-eigenvectors-of-the-matrix" title="Link to this heading">#</a></h3>
<p><span class="math notranslate nohighlight">\(\mathbf{A} = \left(\begin{array}{cc} 
\alpha &amp; \beta \\
-\beta &amp; \alpha \\
\end{array}\right)\)</span></p>
</section>
<section id="example-6-5-given-that-lambda-1-5-is-an-eigenvalue-find-the-remaining-eigenvalues-of-the-matrix">
<h3>Example 6.5: Given that <span class="math notranslate nohighlight">\(\lambda_1 = 5\)</span> is an eigenvalue, find the remaining eigenvalues of the matrix:<a class="headerlink" href="#example-6-5-given-that-lambda-1-5-is-an-eigenvalue-find-the-remaining-eigenvalues-of-the-matrix" title="Link to this heading">#</a></h3>
<p><span class="math notranslate nohighlight">\( \mathbf{A} =  \left(\begin{array}{ccc} 
-2 &amp; +2 &amp; -3 \\
+2 &amp; +1 &amp; -6 \\
-1 &amp; -2 &amp; 0
\end{array}\right)\)</span></p>
<p>We will tackle these, and other problems, with Python numerical packages shortly!</p>
</section>
</section>
<section id="practical-matrix-computing">
<h2>Practical Matrix Computing<a class="headerlink" href="#practical-matrix-computing" title="Link to this heading">#</a></h2>
<p>Many scientific programming bugs arise from improper use of arrays.</p>
<p>These may be a result of the extensive use of matrices, or to the complexity of keeping track of indices and dimensions. Here are some rules of thumb to observe!</p>
<ul class="simple">
<li><p><strong>Computers are finite</strong>: Be careful with matrix memory usage! E.g. if you are storing data in a 4-dimensional array, with each index having a physical dimension of 100, e.g. <code class="docutils literal notranslate"><span class="pre">A[100][100][100][100]</span></code>, then this array will take up <span class="math notranslate nohighlight">\((100)^4\)</span> 64-byte words <span class="math notranslate nohighlight">\(\simeq 1 GB\)</span> of memory! Note that modern computers typically have 8-64 GB of memory (RAM).</p></li>
<li><p><strong>Processing time</strong>: Matrix operations such as inversion require on the order of <span class="math notranslate nohighlight">\(N^3\)</span> steps for a square matrix of dimension <span class="math notranslate nohighlight">\(N\)</span> (number of rows <span class="math notranslate nohighlight">\(\times\)</span> number of columns). E.g. doubling the dimensions of a matrix results in an eightfold increase in the processing time.</p></li>
<li><p><strong>Matrix Storage</strong>: We think of matrices as multi-dimensional blocks of stored numbers, but the computer stores them as linear strings. For instance, a matrix <code class="docutils literal notranslate"><span class="pre">a[3,3]</span></code> in Python is stored in a row-major order:</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">a00</span> <span class="pre">a01</span> <span class="pre">a02</span> <span class="pre">a10</span> <span class="pre">a11</span> <span class="pre">a12</span> <span class="pre">a20</span> <span class="pre">a21</span> <span class="pre">a22</span></code></p>
<p>while in Fortran it is stored in a column-major order:</p>
<p><code class="docutils literal notranslate"><span class="pre">a01</span> <span class="pre">a10</span> <span class="pre">a20</span> <span class="pre">a01</span> <span class="pre">a11</span> <span class="pre">a21</span> <span class="pre">a02</span> <span class="pre">a12</span> <span class="pre">a22</span></code></p>
<p>It is important to keep this in mind in order to write proper code which permits the mixing of Python and Fortran programs!</p>
<ul class="simple">
<li><p><strong>Tests</strong> Always test a library routine on a small problem whose answer you already know. Then you will know if you are using the routine correctly.</p></li>
</ul>
</section>
<section id="matrices-in-python-python-lists-numpy-arrays">
<h2>Matrices in Python: Python Lists, NumPy Arrays<a class="headerlink" href="#matrices-in-python-python-lists-numpy-arrays" title="Link to this heading">#</a></h2>
<section id="python-lists">
<h3>Python Lists<a class="headerlink" href="#python-lists" title="Link to this heading">#</a></h3>
<p>Lists contain sequences of objects that are <em>mutable</em> (i.e. changeable) .</p>
<p>Python also has a builtin type called a <em>tuple</em>. Its elementa are <em>not</em> mutable. (See Chapter 1).</p>
<p>Most programming languages require you to specify the size of an array befor eyou can start storing objects in it. On the other hand, Python lists are dynamic, i.e. their sizes are adjusted as needed.</p>
<p>Compound lists can be created in Python by having the individual elements themselves as lists.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Lists are mutable:</span>
<span class="n">VectorA</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">VectorA</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span> <span class="c1"># we are changing the last element from 3 -&gt; 4</span>
<span class="nb">print</span><span class="p">(</span><span class="n">VectorA</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1, 2, 4]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># On the other hand, tuples are not:</span>
<span class="n">TupleB</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">TupleB</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">TypeError</span><span class="g g-Whitespace">                                 </span>Traceback (most recent call last)
<span class="n">Cell</span> <span class="n">In</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">line</span> <span class="mi">3</span>
<span class="g g-Whitespace">      </span><span class="mi">1</span> <span class="c1"># On the other hand, tuples are not:</span>
<span class="g g-Whitespace">      </span><span class="mi">2</span> <span class="n">TupleB</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="ne">----&gt; </span><span class="mi">3</span> <span class="n">TupleB</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>

<span class="ne">TypeError</span>: &#39;tuple&#39; object does not support item assignment
</pre></div>
</div>
</div>
</div>
</section>
<section id="numpy-arrays">
<h3>NumPy Arrays<a class="headerlink" href="#numpy-arrays" title="Link to this heading">#</a></h3>
<p>Python lists are rather limited. Instead it is recommended to use NumPy arrays for actual mathematical manipulations involving matrices.</p>
<p>NumPy Arrays:</p>
<ul class="simple">
<li><p>Can hold up to 32 dimensions!</p></li>
<li><p>But each element must be of the same type, i.e. the array has to be “uniform”.</p></li>
<li><p>Elements are not resticted to be floats or integers, but can be any ojbect, as long as the elements are of the same type.</p></li>
<li><p>The data types can be compound.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Let&#39;s construct NumPy arrays</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># a NumPy array:</span>
<span class="n">NumpyVectorA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span> 
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;A=&#39;</span><span class="p">,</span><span class="n">NumpyVectorA</span><span class="p">)</span>

<span class="c1"># a compound NumPy array: </span>
<span class="n">NumpyVectorB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;B=&#39;</span><span class="p">,</span><span class="n">NumpyVectorB</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>A= [1 2 3]
B= [[&#39;a&#39; &#39;1&#39;]
 [&#39;b&#39; &#39;2&#39;]
 [&#39;c&#39; &#39;3&#39;]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Multiply a matrix by a number multiplies each element by that number:</span>
<span class="c1"># e.g.:</span>
<span class="n">NumpyVectorA2</span> <span class="o">=</span> <span class="n">NumpyVectorA</span> <span class="o">*</span> <span class="mi">2</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;A*2=&#39;</span><span class="p">,</span> <span class="n">NumpyVectorA2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>A*2= [2 4 6]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># .shape tells you the shape of an array</span>
<span class="c1"># e.g.:</span>
<span class="n">NumpyMatrixC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The shape of NumpyMatrixC is&#39;</span><span class="p">,</span> <span class="n">NumpyMatrixC</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="c1"># or:</span>
<span class="n">NumpyMatrixD</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">]])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The shape of NumpyMatrixD is&#39;</span><span class="p">,</span> <span class="n">NumpyMatrixD</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

<span class="c1"># and .ndim tells you the number of dimensions:</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The number of dimensions for NumpyMatrixD is&#39;</span><span class="p">,</span> <span class="n">NumpyMatrixD</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
<span class="c1"># add a dimension:</span>
<span class="n">NumpyMatrixE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">NumpyMatrixD</span><span class="p">,</span> <span class="n">NumpyMatrixD</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The number of dimensions for NumpyMatrixE is&#39;</span><span class="p">,</span> <span class="n">NumpyMatrixE</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>The shape of NumpyMatrixC is (3, 2)
The shape of NumpyMatrixD is (3, 3)
The number of dimensions for NumpyMatrixD is 2
The number of dimensions for NumpyMatrixE is 3
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># you can get the transpose by the .T operation: </span>
<span class="c1"># e.g.:</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;NumpyMatrixD=&#39;</span><span class="p">,</span><span class="n">NumpyMatrixD</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;NumpyMatrixD transposed=&#39;</span><span class="p">,</span><span class="n">NumpyMatrixD</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>NumpyMatrixD= [[1 2 7]
 [3 4 8]
 [5 6 9]]
NumpyMatrixD transposed= [[1 3 5]
 [2 4 6]
 [7 8 9]]
</pre></div>
</div>
</div>
</div>
<p>To obtain a matrix product from two arrays, you should use the dot function. The * operator between two arrays is used for an element-by-element product.</p>
<p>E.g.:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Element-wise multiplication: </span>
<span class="nb">print</span><span class="p">(</span><span class="n">NumpyMatrixD</span> <span class="o">*</span> <span class="n">NumpyMatrixD</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[ 1  4 49]
 [ 9 16 64]
 [25 36 81]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Matrix Multiplication:</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">NumpyMatrixD</span><span class="p">,</span><span class="n">NumpyMatrixD</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[ 42  52  86]
 [ 55  70 125]
 [ 68  88 164]]
</pre></div>
</div>
</div>
</div>
<p>A major power in NumPy comes from its <em>broadcasting</em> operation, an operation in which values are assigned to multiple elements via a single assignment statement.</p>
<p>Broadcasting permits Python to <em>vectorize</em> array operations, which means that the same operation can be performed on different array elements in parallel (or nearly so).</p>
<p>Broadcasting also speeds up processing because array operations occur in C instead of Python, and with a minimum of array copies being made.</p>
<p>You’ve already been using broadcasting, e.g. when you did the following:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># broadcasting via NumPy is done here </span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="numpy-s-linalg-package">
<h2>NumPy’s linalg Package<a class="headerlink" href="#numpy-s-linalg-package" title="Link to this heading">#</a></h2>
<p>NumPy’s linalg package treates 2D arrays (1D arrays of 1D arrays) as mathematicam matrice, and provides an interface to the powerful LAPACK linear algebra library.</p>
<p>There is much to be gained in speed and reliability from using these libraries, rather than writing your own matrix routines.</p>
<p>As a first example, let’s look at the standard matrix equation:</p>
<p><span class="math notranslate nohighlight">\(\mathbf{A} \vec{x} = \vec{b}\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">linalg</span> <span class="c1"># import the linear algebra package </span>

<span class="c1"># define the array A:</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">22</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">42</span><span class="p">],</span> <span class="p">[</span><span class="mi">55</span><span class="p">,</span><span class="mi">66</span><span class="p">,</span><span class="mi">100</span><span class="p">]</span> <span class="p">])</span> 
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;A=&#39;</span><span class="p">,</span><span class="n">A</span><span class="p">)</span>

<span class="c1"># define the vector b:</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;b=&#39;</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>

<span class="c1"># now solve using linalg&#39;s solve:</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;x=&#39;</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>A= [[  1   2   3]
 [ 22  32  42]
 [ 55  66 100]]
b= [1 2 3]
x= [-1.4057971  -0.1884058   0.92753623]
</pre></div>
</div>
</div>
</div>
<p>We can print the residual of the operation <span class="math notranslate nohighlight">\(\mathbf{A} \vec{x} - \vec{b}\)</span> to check how far we are from zero!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Ax-b=&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Ax-b= [0.0000000e+00 4.4408921e-16 4.4408921e-15]
</pre></div>
</div>
</div>
</div>
<p>Very close to zero indeed!</p>
<p>We have solved entire set of linear equations (by elimination) with just a single command, performed a matrix multiplication with the single command <code class="docutils literal notranslate"><span class="pre">dot</span></code>, did a matrix subtraction, and are left with a residual equal to machine precision!</p>
<p>Although there are more efficient numerical approaches, a direct way to solve the equation is to calculate the inverse of <span class="math notranslate nohighlight">\(\mathbf{A}\)</span>, and then multiply both sides of the equation by the inverse, yielding</p>
<p><span class="math notranslate nohighlight">\(\vec{x} = \mathbf{A}^{-1} \vec{b}\)</span>.</p>
<p>Let’s follow this approach as well!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">linalg</span> <span class="c1"># import the linear algebra package </span>

<span class="c1"># define the array A:</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">22</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">42</span><span class="p">],</span> <span class="p">[</span><span class="mi">55</span><span class="p">,</span><span class="mi">66</span><span class="p">,</span><span class="mi">100</span><span class="p">]</span> <span class="p">])</span> 
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;A=&#39;</span><span class="p">,</span><span class="n">A</span><span class="p">)</span>

<span class="c1"># define the vector b:</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;b=&#39;</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>

<span class="c1"># get the inverse using the linear algebra package:</span>
<span class="n">invA</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> 
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;A^{-1}=&#39;</span><span class="p">,</span> <span class="n">invA</span><span class="p">)</span>

<span class="c1"># test the inverse:</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;A.A^{-1}=&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">invA</span><span class="p">))</span>

<span class="c1"># solve the equation:</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">invA</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;x=&#39;</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>A= [[  1   2   3]
 [ 22  32  42]
 [ 55  66 100]]
b= [1 2 3]
A^{-1}= [[-1.55072464  0.00724638  0.04347826]
 [-0.39855072  0.23550725 -0.08695652]
 [ 1.11594203 -0.15942029  0.04347826]]
A.A^{-1}= [[1.00000000e+00 2.77555756e-17 6.93889390e-18]
 [7.54951657e-15 1.00000000e+00 3.74700271e-16]
 [1.86517468e-14 5.55111512e-16 1.00000000e+00]]
x= [-1.4057971  -0.1884058   0.92753623]
</pre></div>
</div>
</div>
</div>
<p>Same as via the direct method, as expected!</p>
<p>The second type of matrix equation we wish to solve is the eigenvalue equation:</p>
<p><span class="math notranslate nohighlight">\(\mathbf{I} \vec{\omega} = \lambda \vec{\omega}\)</span>,</p>
<p>where in this case, e.g. <span class="math notranslate nohighlight">\(\mathbf{I}\)</span> is the inertia matrix (or tensor) and <span class="math notranslate nohighlight">\(\omega\)</span> is an unknown eigenvector, <span class="math notranslate nohighlight">\(\lambda\)</span> is the unknown eigenvalue.</p>
<p>Then, e.g.:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">linalg</span>

<span class="c1"># the moment of inertia tensor:</span>
<span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">]])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;I=&#39;</span><span class="p">,</span><span class="n">I</span><span class="p">)</span>

<span class="c1"># get the eigenvectors and eigenvalues:</span>
<span class="n">evalues</span><span class="p">,</span> <span class="n">evectors</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Eigenvalues=&#39;</span><span class="p">,</span><span class="n">evalues</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Eigenvectors=&#39;</span><span class="p">,</span><span class="n">evectors</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>I= [[ 0.66666667 -0.25      ]
 [-0.25        0.66666667]]
Eigenvalues= [0.91666667 0.41666667]
Eigenvectors= [[ 0.70710678  0.70710678]
 [-0.70710678  0.70710678]]
</pre></div>
</div>
</div>
</div>
<section id="example-6-6-solve-examples-6-3-to-6-5-numerically">
<h3>Example 6.6: Solve Examples 6.3 to 6.5 numerically!<a class="headerlink" href="#example-6-6-solve-examples-6-3-to-6-5-numerically" title="Link to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">linalg</span>

<span class="c1"># Example 6.3:</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="p">[</span><span class="o">+</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">+</span><span class="mi">8</span><span class="p">]])</span>
<span class="n">detA</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;detA=&#39;</span><span class="p">,</span><span class="n">detA</span><span class="p">)</span>
<span class="n">invA</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;A^{-1}=&#39;</span><span class="p">,</span> <span class="n">invA</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;A.A^{-1}=&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">invA</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>detA= 262.99999999999983
A^{-1}= [[ 0.19771863  0.06463878  0.00760456]
 [-0.121673    0.11406844  0.07224335]
 [-0.03422053 -0.03041825  0.11406844]]
A.A^{-1}= [[ 1.00000000e+00 -1.38777878e-17  0.00000000e+00]
 [ 2.77555756e-17  1.00000000e+00 -5.55111512e-17]
 [ 5.55111512e-17  2.77555756e-17  1.00000000e+00]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example 6.4: Pick numbers alpha = 1, beta = 2:</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">linalg</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>

<span class="c1"># get the eigenvectors and eigenvalues:</span>
<span class="n">evalues</span><span class="p">,</span> <span class="n">evectors</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Eigenvalues=&#39;</span><span class="p">,</span><span class="n">evalues</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Eigenvectors=&#39;</span><span class="p">,</span><span class="n">evectors</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">evectors</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Eigenvalues= [1.+2.j 1.-2.j]
Eigenvectors= [0.        -0.70710678j 0.70710678+0.j        ] [0.        +0.70710678j 0.70710678-0.j        ]
D=UAU^{-1}= [[-1.+0.j  0.-2.j]
 [ 0.+2.j  1.+0.j]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## Example 6.5</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">],[</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">6</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="c1"># to access elements, e.g. 0,0:</span>
<span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

<span class="n">evalues</span><span class="p">,</span> <span class="n">evectors</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Eigenvalues=&#39;</span><span class="p">,</span> <span class="n">evalues</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Eigenvectors=&#39;</span><span class="p">,</span> <span class="n">evectors</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-2
Eigenvalues= [-3.  5. -3.]
Eigenvectors= [[-0.95257934  0.40824829 -0.02296692]
 [ 0.27216553  0.81649658  0.83534731]
 [-0.13608276 -0.40824829  0.54924256]]
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="n-dimensional-newton-raphson">
<h2>N-Dimensional Newton-Raphson<a class="headerlink" href="#n-dimensional-newton-raphson" title="Link to this heading">#</a></h2>
<p>Using what we have learned thus far about matrix computing, we can solve, numerically, any system of <span class="math notranslate nohighlight">\(N\)</span> coupled <em>linear</em> equations, e.g. by directly asking NumPy’s linalg package to solve:</p>
<p><span class="math notranslate nohighlight">\(\mathbf{A} \vec{x} = \vec{b}\)</span>.</p>
<p>What about a system of <span class="math notranslate nohighlight">\(N\)</span> <em>nonlinear</em> equations?</p>
<p>This can also be solved numerically, by combining matrix computing with our methods for searching for roots to equations, such as the Newton-Raphson method.</p>
<p>Let’s discuss the general technique for achieving this, and then apply it to a concrete example in statics.</p>
<p>Let’s suppose that our system of <span class="math notranslate nohighlight">\(N\)</span> equations can be written in terms of <span class="math notranslate nohighlight">\(N\)</span> unknowns, <span class="math notranslate nohighlight">\(x_i\)</span>, <span class="math notranslate nohighlight">\(i=1,2,...,N\)</span>.</p>
<p>We can write all of these unknowns in a single column vector:</p>
<p><span class="math notranslate nohighlight">\(\vec{x} = \left(\begin{array}{ccc} 
x_{1}  \\
x_{2}  \\
\cdots \\
x_{N} 
\end{array}\right)\)</span></p>
<p>and then the <span class="math notranslate nohighlight">\(N\)</span> equations can be written as functions of <span class="math notranslate nohighlight">\(\vec{x}\)</span> as:</p>
<p><span class="math notranslate nohighlight">\(f_i(x_1, x_2, ..., x_N) = 0\)</span></p>
<p>or:</p>
<p><span class="math notranslate nohighlight">\(f_i(\vec{x}) = 0\)</span>, <span class="math notranslate nohighlight">\(i=1,...,N\)</span>.</p>
<p>The solutions to these <span class="math notranslate nohighlight">\(N\)</span> equations are a set of <span class="math notranslate nohighlight">\(N\)</span> values of the <span class="math notranslate nohighlight">\(x_i\)</span> that make the <span class="math notranslate nohighlight">\(f_i\)</span>’s vanish simultaneously.</p>
<p>Our search algorithm will guess a set of <span class="math notranslate nohighlight">\(N\)</span> solutions, expand the nonlinear euqations <span class="math notranslate nohighlight">\(f_i\)</span> into linear form, solves the resulting <em>linear</em> equations, and continues to improve the guesses, based on how close the previous one was to making all the <span class="math notranslate nohighlight">\(f_i(\vec{x}) = 0\)</span>.</p>
<p>Explicitly, let the approximate solutions at any stage be called <span class="math notranslate nohighlight">\(x_i\)</span>’s. To calculate the new set of <span class="math notranslate nohighlight">\(x_i\)</span>’s, <span class="math notranslate nohighlight">\(x_i' = x_i + \Delta x_i\)</span>, for which:</p>
<p><span class="math notranslate nohighlight">\(f_i(x_1 + \Delta x_1, x_2 + \Delta x_2, ..., x_N + \Delta x_N) \approx 0\)</span>, <span class="math notranslate nohighlight">\(i=1,...,N\)</span>.</p>
<p>or, by Taylor series expansion:</p>
<p><span class="math notranslate nohighlight">\(f_i(x_1, ..., x_N) + \sum_{j=1}^N \frac{ \partial f_i }{ \partial x_j } \Delta x_j \approx 0\)</span></p>
<p>we now have a solveble set of <span class="math notranslate nohighlight">\(N\)</span> <em>linear</em> equations, in the <span class="math notranslate nohighlight">\(N\)</span> unknown “modifications” to our current solution, <span class="math notranslate nohighlight">\(\Delta x_i\)</span>, which we can express as a single matrix equation.</p>
<p><span class="math notranslate nohighlight">\(f_1 + \frac{ \partial f_1 }{ \partial x_1 } \Delta x_1 + \frac{ \partial f_1 }{ \partial x_2 } \Delta x_2 + ... + \frac{ \partial f_1 }{ \partial x_N } \Delta x_N = 0\)</span></p>
<p><span class="math notranslate nohighlight">\(f_2 + \frac{ \partial f_2 }{ \partial x_1 } \Delta x_1 + \frac{ \partial f_2 }{ \partial x_2 } \Delta x_2 + ... + \frac{ \partial f_2 }{ \partial x_N } \Delta x_N = 0\)</span></p>
<p><span class="math notranslate nohighlight">\(...\)</span></p>
<p><span class="math notranslate nohighlight">\(f_N + \frac{ \partial f_N }{ \partial x_1 } \Delta x_1 + \frac{ \partial f_N }{ \partial x_2 } \Delta x_2 + ... + \frac{ \partial f_N }{ \partial x_N } \Delta x_N = 0\)</span></p>
<p>or in matrix form:</p>
<p><span class="math notranslate nohighlight">\(\left(\begin{array}{c} 
f_{1}  \\
f_{2}  \\
\ddots \\
f_{N} 
\end{array}\right) + \left(\begin{array}{cccc} 
\frac{ \partial f_1 }{ \partial x_1 } &amp; \frac{ \partial f_1 }{ \partial x_2 } &amp; ... &amp;  \frac{ \partial f_1 }{ \partial x_N }\\
\frac{ \partial f_2 }{ \partial x_1 } &amp; \frac{ \partial f_2 }{ \partial x_2 } &amp; ... &amp; \frac{ \partial f_2 }{ \partial x_N } \\
\ddots &amp; \ddots &amp;  \ddots &amp; \ddots \\
\frac{ \partial f_N }{ \partial x_1 } &amp; \frac{ \partial f_N }{ \partial x_2 } &amp; ... &amp; \frac{ \partial f_N }{ \partial x_N }
\end{array}\right)\left(\begin{array}{c} 
\Delta x_{1}  \\
\Delta x_{2}  \\
\ddots \\
\Delta x_{N} 
\end{array}\right) = 0\)</span></p>
<p>The derivatives and the <span class="math notranslate nohighlight">\(f_i\)</span>’s are all evaluated at <em>known</em> values of the previous guesses, <span class="math notranslate nohighlight">\(x_i\)</span>, so that only the vector of the modifications, <span class="math notranslate nohighlight">\(\Delta x_i\)</span>, is unknown.</p>
<p>We may write the above equation in matrix notation as:</p>
<p><span class="math notranslate nohighlight">\(\vec{f} + \mathbf{J} \Delta \vec{x} = 0\)</span></p>
<p>where:</p>
<p><span class="math notranslate nohighlight">\(\vec{f} = \left(\begin{array}{c} 
f_{1}  \\
f_{2}  \\
\ddots \\
f_{N} 
\end{array}\right)\)</span>, <span class="math notranslate nohighlight">\(\Delta \vec{x} = \left(\begin{array}{c} 
\Delta x_{1}  \\
\Delta x_{2}  \\
\ddots \\
\Delta x_{N} 
\end{array}\right)\)</span>, <span class="math notranslate nohighlight">\(\mathbf{J} = \left(\begin{array}{cccc} 
\frac{ \partial f_1 }{ \partial x_1 } &amp; \frac{ \partial f_1 }{ \partial x_2 } &amp; ... &amp;  \frac{ \partial f_1 }{ \partial x_N }\\
\frac{ \partial f_2 }{ \partial x_1 } &amp; \frac{ \partial f_2 }{ \partial x_2 } &amp; ... &amp; \frac{ \partial f_2 }{ \partial x_N } \\
\ddots &amp; \ddots &amp;  \ddots &amp; \ddots \\
\frac{ \partial f_N }{ \partial x_1 } &amp; \frac{ \partial f_N }{ \partial x_2 } &amp; ... &amp; \frac{ \partial f_N }{ \partial x_N }
\end{array}\right)\)</span>,</p>
<p>and where <span class="math notranslate nohighlight">\(\mathbf{J}\)</span> is known as the Jacobian matrix.</p>
<p>Then:</p>
<p><span class="math notranslate nohighlight">\(\mathbf{J} \Delta \vec{x} = -\vec{f}\)</span>.</p>
<p>The above is equivalent to the one-dimensional Newton-Raphson formula: <span class="math notranslate nohighlight">\(\Delta x = -(1/f') f\)</span>.</p>
<p>Comparing this to the standard matrix form of a system of <span class="math notranslate nohighlight">\(N\)</span> linear equations with <span class="math notranslate nohighlight">\(N\)</span> unknows:</p>
<p><span class="math notranslate nohighlight">\(\mathbf{A} \vec{x} = \vec{b}\)</span>,</p>
<p>we can identify <span class="math notranslate nohighlight">\(\mathbf{A} \rightarrow \mathbf{J}\)</span>, <span class="math notranslate nohighlight">\(\vec{x} \rightarrow \Delta \vec{x}\)</span> and <span class="math notranslate nohighlight">\(\vec{b} \rightarrow -\vec{f}\)</span>.</p>
<p>This can be solved using the techniques of linear algebra, i.e. in our case, using NumPy’s <code class="docutils literal notranslate"><span class="pre">linalg</span></code> module.</p>
<p>Note that the solution of such problems requires either analytical or numerical calculation of the <span class="math notranslate nohighlight">\(N^2\)</span> partial derivatives <span class="math notranslate nohighlight">\(\partial f_i / \partial x_j\)</span>, the elements of the Jacobian matrix, <span class="math notranslate nohighlight">\(\mathbf{J}\)</span>. It is usually more straightforward to program a numerical approximation for the derivatives, e.g. a central-difference approximation:</p>
<p><span class="math notranslate nohighlight">\(\frac{ \partial f_i }{ \partial x_j } \simeq \frac{ f_i(x_j + \delta x_j) - f_i(x_j) } { \delta x_j}\)</span>,</p>
<p>where we vary each <span class="math notranslate nohighlight">\(x_j\)</span> independently and <span class="math notranslate nohighlight">\(\delta x_j\)</span> are some arbitrary changes you input.</p>
<p>As for the case of the one-dimensional Newton-Raphson method, this search can fail if the initial guess is not close enough to the zero of all the <span class="math notranslate nohighlight">\(f_i\)</span>’s so that they can be approximated by a linear function. The backtracking technique may be applied here as well, in the present case, progressively decreasing the corrections <span class="math notranslate nohighlight">\(\Delta x_i\)</span>, until <span class="math notranslate nohighlight">\(|f|^2 = |f_1|^2 + |f_2|^2 + ... + |f_N|^2\)</span> decreases.</p>
</section>
<section id="more-matrix-examples">
<h2>More Matrix Examples<a class="headerlink" href="#more-matrix-examples" title="Link to this heading">#</a></h2>
<p>Before we proceed to Exercise 6.2, let’s tackle two more matrix problems.</p>
<section id="example-6-6-your-model-of-some-physical-system-results-in-n-100-coupled-linear-equations-with-n-unknowns">
<h3>Example 6.6: Your model of some physical system results in <span class="math notranslate nohighlight">\(N=100\)</span> coupled linear equations with <span class="math notranslate nohighlight">\(N\)</span> unknowns:<a class="headerlink" href="#example-6-6-your-model-of-some-physical-system-results-in-n-100-coupled-linear-equations-with-n-unknowns" title="Link to this heading">#</a></h3>
<p><span class="math notranslate nohighlight">\(a_{00} y_0 + a_{01} y_1 + ... + a_{0(N-1)} y_{N-1} = b_0\)</span></p>
<p><span class="math notranslate nohighlight">\(a_{10} y_0 + a_{11} y_1 + ... + a_{1(N-1)} y_{N-1} = b_1\)</span></p>
<p><span class="math notranslate nohighlight">\(...\)</span></p>
<p><span class="math notranslate nohighlight">\(a_{(N-1)0} y_0 + a_{(N-1)1} y_1 + ... + a_{(N-1)(N-1)} y_{N-1} = b_{N-1}\)</span></p>
<p>In this example, take the matrix <span class="math notranslate nohighlight">\(\mathbf{a}\)</span> to be the Hilbert matrix (see <a class="reference external" href="https://en.wikipedia.org/wiki/Hilbert_matrix">https://en.wikipedia.org/wiki/Hilbert_matrix</a>) and <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> its first column:</p>
<p><span class="math notranslate nohighlight">\(\mathbf{a} = \left(\begin{array}{c} 
1 &amp; \frac{1}{2} &amp; \frac{1}{3} &amp; \frac{1}{4} &amp; ... &amp; \frac{1}{100}  \\
\frac{1}{2} &amp; \frac{1}{3} &amp; \frac{1}{4} &amp; \frac{1}{5} &amp; ... &amp; \frac{1}{101} \\
\ddots &amp; \ddots &amp; \ddots &amp; \ddots &amp;  \ddots &amp; \ddots \\
\frac{1}{100} &amp; \frac{1}{101} &amp; \frac{1}{102} &amp; ... &amp; ... &amp; \frac{1}{199}
\end{array}\right)\)</span></p>
<p>or <span class="math notranslate nohighlight">\(a_{ij} = \frac{1}{i+j - 1}\)</span>.</p>
<p>and <span class="math notranslate nohighlight">\(\vec{b} = \left(\begin{array}{c}
1 \\
\frac{1}{2}\\
\frac{1}{3}\\
\ddots\\
\frac{1}{100}\end{array}\right)
\)</span></p>
<p>Solve the matrix equation, <span class="math notranslate nohighlight">\(\mathbf{a} \vec{y} = \vec{b}\)</span> numerically, and compare to the analytic solution:
<span class="math notranslate nohighlight">\(\vec{y} = \left(\begin{array}{c}
1 \\
0\\
\ddots\\
0\\
\end{array}\right)
\)</span></p>
</section>
<section id="example-6-7-dirac-gamma-matrices">
<h3>Example 6.7: Dirac Gamma Matrices<a class="headerlink" href="#example-6-7-dirac-gamma-matrices" title="Link to this heading">#</a></h3>
<p>The Dirac equation extends quantum mechanics to include relativity and spin-1/2 particles (fermions). The extension of the Hamiltonian operator for an electron (a fermion), requires it to contain matrices, and those matrices are expressed in terms of <span class="math notranslate nohighlight">\(4 \times 4\)</span> <span class="math notranslate nohighlight">\(\mathbf{\gamma}\)</span> matrices, that can be represented in terms of the familiar <span class="math notranslate nohighlight">\(2 \times 2\)</span> Pauli matrices <span class="math notranslate nohighlight">\(\mathbf{\sigma}_i\)</span>:</p>
<p><span class="math notranslate nohighlight">\(\mathbf{\gamma}_i = \left(\begin{array}{c}
0 &amp; \mathbf{\sigma}_i \\
-\mathbf{\sigma}_i &amp; 0\\
\end{array}\right)
\)</span>, <span class="math notranslate nohighlight">\(i=1,2,3\)</span>,</p>
<p>where:</p>
<p><span class="math notranslate nohighlight">\(\mathbf{\sigma}_1 = \left(\begin{array}{c}
0 &amp; 1 \\
1 &amp; 0\\
\end{array}\right)
\)</span>, <span class="math notranslate nohighlight">\(\mathbf{\sigma}_2 = \left(\begin{array}{c}
0 &amp; -i \\
i &amp; 0\\
\end{array}\right)
\)</span>, <span class="math notranslate nohighlight">\(\mathbf{\sigma}_3 = \left(\begin{array}{c}
1 &amp; 0 \\
0 &amp; -1\\
\end{array}\right)\)</span>.</p>
<p>Confirm the following properties of the <span class="math notranslate nohighlight">\(\mathbf{\gamma}\)</span> matrices:</p>
<p><span class="math notranslate nohighlight">\(\mathbf{\gamma}_2^\dagger = \mathbf{\gamma}_2^{-1}  = - \mathbf{\gamma}_{2}\)</span>,</p>
<p>and</p>
<p><span class="math notranslate nohighlight">\(\mathbf{\gamma}_1 \mathbf{\gamma}_2 = -i \left(\begin{array}{c}
\mathbf{\sigma}_3 &amp; 0\\
0 &amp; \mathbf{\sigma}_3\\
\end{array}\right)\)</span></p>
</section>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="data-fitting">
<h1>Data Fitting<a class="headerlink" href="#data-fitting" title="Link to this heading">#</a></h1>
<p>Data fitting is an art that should be studied by all scientists.</p>
<p>This section gives an introduction to the subject, examining how to interpolate data, and how to perform least-squares fits to data.</p>
<p>A problem that we wish to tackle: Given a table of measured values, e.g. cross sections for the resonant scattering of neutrons from a nucleus at certain energies, we wish to determine the values for the cross sections at energy values lying between those in the table.</p>
<p>e.g.:</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Energy (MeV)</p></th>
<th class="head"><p>Cross Section (mb)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>10.6</p></td>
</tr>
<tr class="row-odd"><td><p>25</p></td>
<td><p>16.0</p></td>
</tr>
<tr class="row-even"><td><p>50</p></td>
<td><p>45.0</p></td>
</tr>
<tr class="row-odd"><td><p>75</p></td>
<td><p>83.5</p></td>
</tr>
<tr class="row-even"><td><p>100</p></td>
<td><p>52.8</p></td>
</tr>
<tr class="row-odd"><td><p>125</p></td>
<td><p>19.9</p></td>
</tr>
<tr class="row-even"><td><p>150</p></td>
<td><p>10.8</p></td>
</tr>
<tr class="row-odd"><td><p>175</p></td>
<td><p>8.25</p></td>
</tr>
<tr class="row-even"><td><p>200</p></td>
<td><p>4.7</p></td>
</tr>
</tbody>
</table>
<p>This problem can be solved in different ways:</p>
<ul class="simple">
<li><p><em>Interpolation</em>: The simplest is to numerically interpolate between the values of the experimental data. This is direct and easy, but does not account for there being experimental noise (i.e. errors) in the data.</p></li>
<li><p><em>Least-squares fitting</em>: A more appropriate solution is to find the best fit of a theoretical function to the data: start with what we believe to be the “correct” theoretical description of the data, e.g.:</p></li>
</ul>
<p><span class="math notranslate nohighlight">\( f(E) = \frac{ f_r } { (E-E_r)^2 + \Gamma^2/4 }\)</span>,</p>
<p>where <span class="math notranslate nohighlight">\(f_r\)</span>, <span class="math notranslate nohighlight">\(E_r\)</span> and <span class="math notranslate nohighlight">\(\Gamma\)</span> are unknown parameters, and then adjust the parameters to obtain the best fit, in the statistical sense. This best fit may not pass through all (or any!) points.</p>
<p>Both interpolation and least-squares fitting are powerful tools that let you treat tables of numbers as if they were analytic functions, and sometimes let you dedduce statistically meaningful constraints from measurements.</p>
<section id="lagrange-interpolation">
<h2>Lagrange Interpolation<a class="headerlink" href="#lagrange-interpolation" title="Link to this heading">#</a></h2>
<p>Consider a table of data taht we wish to interpolate. We call the independent variables <span class="math notranslate nohighlight">\(x\)</span> and its tabulated values <span class="math notranslate nohighlight">\(x_i\)</span>, (<span class="math notranslate nohighlight">\(i=1,2,...\)</span>). We assume that the dependent variable is represented by a function <span class="math notranslate nohighlight">\(g(x)\)</span>, with tabulated values <span class="math notranslate nohighlight">\(g_i = g(x_i)\)</span>.</p>
<p>In Lagrange interpolation, we assume that <span class="math notranslate nohighlight">\(g(x)\)</span> can be approximated as an <span class="math notranslate nohighlight">\((n-1)\)</span>-degree polynomial in each interval <span class="math notranslate nohighlight">\(i\)</span>:</p>
<p><span class="math notranslate nohighlight">\(g_i(x) \simeq a_0 + a_1 x + a_2 x^2 + ... + a_{n-1} x^{n-1}\)</span> for <span class="math notranslate nohighlight">\(x\simeq x_i\)</span>.</p>
<p>This fit is <em>local</em>: we do not assume that one single function can fit all the data in the table, but instead use a different polynomial (i.e. different set of <span class="math notranslate nohighlight">\(a_i\)</span>’s) for each interval.</p>
<p>If care is taken, the set of polynomials obtained this way will be used in further calculations, without introducing too much unwanted noise or discontinuities.</p>
<p>The classic interpolation formula was created by Lagrange. In this method, the formula for each interval is written as the sum of polynomialsa:</p>
<p><span class="math notranslate nohighlight">\(g(x) \simeq g_1 \lambda_1 (x) + g_2 \lambda_2 (x) + ... + g_n \lambda_n(x)\)</span>,</p>
<p>where the <span class="math notranslate nohighlight">\(g_i\)</span> are the measured values of the dependent variable (e.g. the cross section) and the <span class="math notranslate nohighlight">\(\lambda_i\)</span>’s can be calculated via:</p>
<p><span class="math notranslate nohighlight">\(\lambda_i = \prod_{j=1, j\neq i}^n \frac{ x - x_j } { x_i - x_j}\)</span>,</p>
<p>or explicitly:</p>
<p><span class="math notranslate nohighlight">\(\lambda_i = \frac{ x - x_1 } { x_i - x_1} \frac{ x - x_2 } { x_i - x_2} ... \frac{ x - x_n } { x_i - x_n}\)</span>.</p>
<p>E.g. with three points, you would get a second-degree polynomial.</p>
<p>E.g. Assume that we are given the pts and function values:</p>
<p><span class="math notranslate nohighlight">\(x_i=(0,1,2,4)\)</span> and <span class="math notranslate nohighlight">\(g_i = (-12, -12, -24, -60)\)</span>.</p>
<p>With four points, the Lagrange formula determines a third-order polynomial that reproduces each of the tabulated values.</p>
<p><span class="math notranslate nohighlight">\(g(x) = \frac{ (x-1) (x-2) (x-4) } { (0-1) (0-2) (0-4) } (-12) + \frac{ (x-0) (x-2) (x-4) } { (1-0)(1-2)(1-4) } (-12) + \frac{ (x-0) (x-1) (x-4) }{ (2-0) (2-1) (2-4) } (-24)\)</span>
<span class="math notranslate nohighlight">\(+ \frac{ (x-0)(x-1)(x-2)} { (4-0) (4-1)(4-2) } (-60)\)</span>.</p>
<p><span class="math notranslate nohighlight">\(\Rightarrow g(x) = x^3 - 9x^2 + 8x - 12\)</span></p>
<p>Then:</p>
<p><span class="math notranslate nohighlight">\(g(4) = 4^3 - 9 (4^2) + 32 - 12 = -60\)</span>,
<span class="math notranslate nohighlight">\(g(0.5) = -10.125\)</span>.</p>
<p>If the data contain little noise, the polynomial can be used with some confidence within the range of the data, but with some risk beyond the range of the data.</p>
<p>Note that Lagrange interpolation has no restriction that the points <span class="math notranslate nohighlight">\(x_i\)</span> be evenly spaced.</p>
<p>Usually the Lagrange method is applied only to a small region of the table, with a small value of <span class="math notranslate nohighlight">\(n\)</span>, despite the fact that thew formula works perfect well for fitting a high-degree polynomial to the entire table.</p>
<p>The difference between the value of the polynomial and the actual function can be shown to be large if high derivatives exist in <span class="math notranslate nohighlight">\(g(x)\)</span>, which would be the case if the data is noisy.</p>
<p>Let’s apply Lagrange interpolation to the neutron scattering data!</p>
<section id="example-6-8-lagrange-interpolation">
<h3>Example 6.8: Lagrange Interpolation<a class="headerlink" href="#example-6-8-lagrange-interpolation" title="Link to this heading">#</a></h3>
<p>Apply <span class="math notranslate nohighlight">\(n\)</span>-point Lagrange interpolation to the data given in the table above, varying the number of points <span class="math notranslate nohighlight">\(n\)</span>. Plot both the data points and the resulting fits.</p>
<p>Which number of points “looks” the best?</p>
</section>
</section>
<section id="cubic-spline-interpolation">
<h2>Cubic Spline Interpolation<a class="headerlink" href="#cubic-spline-interpolation" title="Link to this heading">#</a></h2>
<p>Through our example of trying to interpolate the resonant cross section with Lagrange interpolation, we saw that fitting parabolas (i.e. 3-point interpolation), within subintervals in the table, may avoid the erroneous and possibly catastrophic deviations of a high-order formula (e.g. 9-point interpolation).</p>
<p>We also saw that a two-point interpolation with straight lines may not lead you far astray, but it is rarely pleasing to the eye, or precise.</p>
<p>A sophisticated variation of an <span class="math notranslate nohighlight">\(n=4\)</span> interpolation, known as <em>cubic splines</em>, often leads to surprisingly eye-pleasing fits.</p>
<p>In this approach, cubic polynomials are fit to the function in each interval, with the additonal constraint that the first and second derivatives be continuous from one interval to the next. The continuity of the slope and curvature is what makes the spline interpolation fit particularly eye-pleasing.</p>
<p>The series of cubic polynomials obtained by spline-fitting a table of data can be integrated and differentiated, and is guaranteed to have well-behaved derivative. The existence of meaningful derivatives is an important consideration: e.g. if the function is a potential,  you can take the derivative to obtain the force.</p>
<p>The complexity of simultaneously matching polynomials and their derivatives over all the interpolation points leads to many simultaneous linear equations to be solved. This makes splines unattractive for calculations by hand, yet easy for computers, and popular in both calculations and computer drawing programs.</p>
<section id="example-6-9-cubic-spline-interpolation-with-scipy">
<h3>Example 6.9: Cubic Spline Interpolation with scipy<a class="headerlink" href="#example-6-9-cubic-spline-interpolation-with-scipy" title="Link to this heading">#</a></h3>
<p>Let’s use SciPy’s interpolation packages to interpolate the resonant cross section.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">interpolate</span>

<span class="c1"># the data: </span>
<span class="n">xdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">125</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">175</span><span class="p">,</span> <span class="mi">200</span><span class="p">])</span>
<span class="n">ydata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">10.6</span><span class="p">,</span> <span class="mf">16.0</span><span class="p">,</span> <span class="mf">45.0</span><span class="p">,</span> <span class="mf">83.5</span><span class="p">,</span> <span class="mf">52.8</span><span class="p">,</span> <span class="mf">19.9</span><span class="p">,</span> <span class="mf">10.8</span><span class="p">,</span> <span class="mf">8.25</span><span class="p">,</span> <span class="mf">4.7</span><span class="p">])</span>

<span class="c1"># the x coordinates where we want to perform the interpolation:</span>
<span class="n">xinterp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

<span class="c1"># Cubic Spline Interpolation:</span>
<span class="n">cs</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">CubicSpline</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">)</span>
<span class="c1"># this creates a function &quot;cs&quot;, that we can use at specific points to create the interpolated y-coordinates </span>
<span class="n">yinterp</span> <span class="o">=</span> <span class="n">cs</span><span class="p">(</span><span class="n">xinterp</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># and now let&#39;s plot: </span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span> <span class="c1"># import matplotlib, a conventional module name is plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span> <span class="c1"># create the elements required for matplotlib. This creates a figure containing a single axes.</span>

<span class="c1"># set the labels and titles:</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$E$ (MeV)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span> <span class="c1"># set the x label</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\frac{\mathrm</span><span class="si">{d}</span><span class="s1">\sigma}{\mathrm</span><span class="si">{d}</span><span class="s1">E}$ (mB/MeV)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span> <span class="c1"># set the y label </span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Cubic Spline Interpolation (scipy)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span> <span class="c1"># set the title </span>

<span class="c1"># plot the data</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">ms</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">)</span> 
<span class="c1"># plot the interpolations</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xinterp</span><span class="p">,</span> <span class="n">yinterp</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Cubic Splines&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span> 

<span class="c1"># construct the legend:</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper right&#39;</span><span class="p">)</span>  <span class="c1"># Add a legend</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span> <span class="c1"># show the plot here</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/603cbe2bddf4988e91373b71e4a44cd65b4c9a009da9f96c09e1dc9aa1f00865.png" src="../_images/603cbe2bddf4988e91373b71e4a44cd65b4c9a009da9f96c09e1dc9aa1f00865.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># You can also access the derivatives!</span>

<span class="c1"># and now let&#39;s plot: </span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span> <span class="c1"># import matplotlib, a conventional module name is plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span> <span class="c1"># create the elements required for matplotlib. This creates a figure containing a single axes.</span>

<span class="c1"># set the labels and titles:</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$E$ (MeV)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span> <span class="c1"># set the x label</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;derivatives&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span> <span class="c1"># set the y label </span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Cubic Spline Interpolation (scipy)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span> <span class="c1"># set the title </span>

<span class="c1"># Plot the derivatives: </span>
<span class="c1"># cs(xinterp, nu=1) calculates the first derivative, etc.</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xinterp</span><span class="p">,</span> <span class="n">cs</span><span class="p">(</span><span class="n">xinterp</span><span class="p">,</span><span class="n">nu</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;1st derivative&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">)</span> 
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xinterp</span><span class="p">,</span> <span class="n">cs</span><span class="p">(</span><span class="n">xinterp</span><span class="p">,</span><span class="n">nu</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;2nd derivative&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">)</span> 
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xinterp</span><span class="p">,</span> <span class="n">cs</span><span class="p">(</span><span class="n">xinterp</span><span class="p">,</span><span class="n">nu</span><span class="o">=</span><span class="mi">3</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;3rd derivative&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span> 

<span class="c1"># construct the legend:</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper right&#39;</span><span class="p">)</span>  <span class="c1"># Add a legend</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span> <span class="c1"># show the plot here</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/0fbb6a7784d684873b5cda7747cfe1b61877e85e4cfa2209ab5e111a94319fe2.png" src="../_images/0fbb6a7784d684873b5cda7747cfe1b61877e85e4cfa2209ab5e111a94319fe2.png" />
</div>
</div>
</section>
</section>
<section id="other-scipy-interpolators">
<h2>Other SciPy Interpolators<a class="headerlink" href="#other-scipy-interpolators" title="Link to this heading">#</a></h2>
<p>There are many other 1-D interpolating methods in SciPy’s interpolate module:</p>
<p>Cubic splines are by construction twice continuously differentiable. This may lead to the spline function oscillating and “overshooting” in between the data points. In these situations, an alternative is to use the so-called monotone cubic interpolants: these are constructed to be only once continuously differentiable, and attempt to preserve the local shape implied by the data. <code class="docutils literal notranslate"><span class="pre">scipy.interpolate</span></code> provides two objects of this kind: PchipInterpolator and Akima1DInterpolator:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ak</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">Akima1DInterpolator</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">)</span> <span class="c1"># Akima 1D interpolator</span>
<span class="n">pc</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">PchipInterpolator</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">)</span> <span class="c1"># Pchip interpolator</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># and now let&#39;s plot: </span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span> <span class="c1"># import matplotlib, a conventional module name is plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span> <span class="c1"># create the elements required for matplotlib. This creates a figure containing a single axes.</span>

<span class="c1"># set the labels and titles:</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$E$ (MeV)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span> <span class="c1"># set the x label</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\frac{\mathrm</span><span class="si">{d}</span><span class="s1">\sigma}{\mathrm</span><span class="si">{d}</span><span class="s1">E}$ (mB/MeV)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span> <span class="c1"># set the y label </span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Cubic Spline Interpolation (scipy)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span> <span class="c1"># set the title </span>

<span class="c1"># plot the data</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">ms</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">)</span> 
<span class="c1"># plot the interpolations</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xinterp</span><span class="p">,</span> <span class="n">yinterp</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Cubic Splines&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span> 
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xinterp</span><span class="p">,</span> <span class="n">ak</span><span class="p">(</span><span class="n">xinterp</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Akima1D&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span> 
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xinterp</span><span class="p">,</span> <span class="n">pc</span><span class="p">(</span><span class="n">xinterp</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;pchip&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;-.&#39;</span><span class="p">)</span> 

<span class="c1"># construct the legend:</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper right&#39;</span><span class="p">)</span>  <span class="c1"># Add a legend</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span> <span class="c1"># show the plot here</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/e0c46174b141d008dfa7ad223feac4b4ff555384a712ab25350702b1d701170a.png" src="../_images/e0c46174b141d008dfa7ad223feac4b4ff555384a712ab25350702b1d701170a.png" />
</div>
</div>
<p>B-splines form an alternative (if formally equivalent) representation of piecewise polynomials. This basis is generally more computationally stable than the power basis and is useful for a variety of applications which include interpolation, regression and curve representation. Details are given in the SciPy piecewise polynomials section (<a class="reference external" href="https://docs.scipy.org/doc/scipy/tutorial/interpolate/splines_and_polynomials.html#tutorial-interpolate-ppoly">https://docs.scipy.org/doc/scipy/tutorial/interpolate/splines_and_polynomials.html#tutorial-interpolate-ppoly</a>), and here we illustrate their usage:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># B-spline interpolator</span>
<span class="n">bspl</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">make_interp_spline</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># and now let&#39;s plot: </span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span> <span class="c1"># import matplotlib, a conventional module name is plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span> <span class="c1"># create the elements required for matplotlib. This creates a figure containing a single axes.</span>

<span class="c1"># set the labels and titles:</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$E$ (MeV)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span> <span class="c1"># set the x label</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\frac{\mathrm</span><span class="si">{d}</span><span class="s1">\sigma}{\mathrm</span><span class="si">{d}</span><span class="s1">E}$ (mB/MeV)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span> <span class="c1"># set the y label </span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Cubic Spline Interpolation (scipy)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span> <span class="c1"># set the title </span>

<span class="c1"># plot the data</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">ms</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">)</span> 
<span class="c1"># plot the interpolations</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xinterp</span><span class="p">,</span> <span class="n">yinterp</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Cubic Splines&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span> 
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xinterp</span><span class="p">,</span> <span class="n">ak</span><span class="p">(</span><span class="n">xinterp</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Akima1D&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span> 
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xinterp</span><span class="p">,</span> <span class="n">pc</span><span class="p">(</span><span class="n">xinterp</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;pchip&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;-.&#39;</span><span class="p">)</span> 
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xinterp</span><span class="p">,</span> <span class="n">bspl</span><span class="p">(</span><span class="n">xinterp</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;B-Splines&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">)</span> 

<span class="c1"># construct the legend:</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper right&#39;</span><span class="p">)</span>  <span class="c1"># Add a legend</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span> <span class="c1"># show the plot here</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/3327881da3a808994fbc449cd2dde51b443d28510dd5e8cdbe63b301decdc95c.png" src="../_images/3327881da3a808994fbc449cd2dde51b443d28510dd5e8cdbe63b301decdc95c.png" />
</div>
</div>
<p>By default, the result of <code class="docutils literal notranslate"><span class="pre">make_interp_spline(x,</span> <span class="pre">y)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">CubicSpline(x,</span> <span class="pre">y)</span></code>. The difference is that the former allows several optional capabilities, e.g. it can construct splines of various degrees (via the optional argument <code class="docutils literal notranslate"><span class="pre">k</span></code>).</p>
<section id="example-6-10-global-temperature-load-data-with-pandas-and-interpolate-with-scipy">
<h3>Example 6.10: Global Temperature: Load data with Pandas and Interpolate with SciPy<a class="headerlink" href="#example-6-10-global-temperature-load-data-with-pandas-and-interpolate-with-scipy" title="Link to this heading">#</a></h3>
<p>Taken from: <a class="reference external" href="https://climate.nasa.gov/vital-signs/global-temperature/">https://climate.nasa.gov/vital-signs/global-temperature/</a></p>
<p>This graph (data from: “No_Smoothing” column of <a class="reference external" href="https://data.giss.nasa.gov/gistemp/graphs/graph_data/Global_Mean_Estimates_based_on_Land_and_Ocean_Data/graph.txt">https://data.giss.nasa.gov/gistemp/graphs/graph_data/Global_Mean_Estimates_based_on_Land_and_Ocean_Data/graph.txt</a>) shows the change in global surface temperature compared to the long-term average from 1951 to 1980. Earth’s average surface temperature in 2023 was the warmest on record since recordkeeping began in 1880 (source: NASA/GISS).</p>
<p>Let’s load the data using Python’s <code class="docutils literal notranslate"><span class="pre">pandas</span></code> and interpolate them. We can use (very cautiously in this case – this is not a model!) what the temperature <em>could</em> be in 2050.</p>
<p>Note that the cubic splines will simply pass through all the points: we don’t want that. Here we will see an example of interpolation with “smoothing”.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span> <span class="c1"># pandas is a useful and widely-used tool for data analysis</span>

<span class="c1"># load the data:</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;graph.txt&#39;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span> <span class="c1"># &#39;\t&#39; represents tabs</span>
<span class="c1"># change the names to the expected ones</span>
<span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Year&quot;</span><span class="p">,</span> <span class="s2">&quot;Temp&quot;</span><span class="p">]</span>
<span class="c1"># print to see how it looks like</span>
<span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

<span class="c1"># we can access the columns as df[&quot;Year&quot;] and df[&quot;Temp&quot;]</span>
<span class="c1"># let&#39;s interpolate using various methods:</span>
<span class="n">xinterp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1880</span><span class="p">,</span><span class="mi">2050</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="c1"># interpolators:</span>
<span class="n">bspl</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">make_interp_spline</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Year&quot;</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;Temp&quot;</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># This will pass through all the points. We&#39;d rather use something that generates smoothing:</span>
<span class="n">spl</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">splrep</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Year&quot;</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;Temp&quot;</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span> <span class="c1"># s determines the degree of smoothing</span>

<span class="c1"># get the data points:</span>
<span class="n">yinterp</span> <span class="o">=</span> <span class="n">bspl</span><span class="p">(</span><span class="n">xinterp</span><span class="p">)</span> 
<span class="n">ysmooth</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">splev</span><span class="p">(</span><span class="n">xinterp</span><span class="p">,</span> <span class="n">spl</span><span class="p">,</span> <span class="n">der</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>     Year  Temp
0    1881 -0.08
1    1882 -0.10
2    1883 -0.16
3    1884 -0.27
4    1885 -0.33
..    ...   ...
138  2019  0.98
139  2020  1.01
140  2021  0.84
141  2022  0.89
142  2023  1.17

[143 rows x 2 columns]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Let&#39;s plot them!</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span> <span class="c1"># import matplotlib, a conventional module name is plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span> <span class="c1"># create the elements required for matplotlib. This creates a figure containing a single axes.</span>

<span class="c1"># set the labels and titles:</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Year&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span> <span class="c1"># set the x label</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Temperature Anomaly vs. Average from 1951-1980 (C$^\circ$)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span> <span class="c1"># set the y label </span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Temperature Anomaly Interpolation&#39;</span><span class="p">)</span>

<span class="c1"># let&#39;s plot the pandas data:</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;Year&#39;</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Temp&#39;</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="c1"># and the interpolations:</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xinterp</span><span class="p">,</span> <span class="n">yinterp</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;B-Splines&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">)</span> 
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xinterp</span><span class="p">,</span> <span class="n">ysmooth</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Splines with smoothing&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;orange&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">)</span> 

<span class="c1"># set limits:</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># construct the legend:</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper center&#39;</span><span class="p">)</span>  <span class="c1"># Add a legend</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span> <span class="c1"># show the plot here</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/bc68b6cdc8774d9c173da1912d17cb2e57407d320b59380b56f2b3c382c2cc65.png" src="../_images/bc68b6cdc8774d9c173da1912d17cb2e57407d320b59380b56f2b3c382c2cc65.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Extrapolated temperature anomaly in 2050:&quot;</span><span class="p">,</span> <span class="n">ysmooth</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Extrapolated temperature anomaly in 2050: 1.8363666133560785
</pre></div>
</div>
</div>
</div>
<p>As we will see later in this chapter, data with so much noise is better addressed by least-squares fitting with a theoretical prediction rather than an interpolator.</p>
</section>
<section id="d-interpolation">
<h3>2-D Interpolation<a class="headerlink" href="#d-interpolation" title="Link to this heading">#</a></h3>
<p>You can also interpolate in multiple dimensions. Let’s look at an example in 2D, i.e. two independent variables and one dependent variable that we wish to interpolate.</p>
<p>E.g. we have the data:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># the data:</span>
<span class="n">xdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="n">ydata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">zdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>

<span class="c1"># interpolating points:</span>
<span class="n">xinterp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">xdata</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">xdata</span><span class="p">))</span>
<span class="n">yinterp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">ydata</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">ydata</span><span class="p">))</span>

<span class="c1"># bivariate B-spline representation of a surface.</span>
<span class="n">tck</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">bisplrep</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">,</span> <span class="n">zdata</span><span class="p">,</span> <span class="n">kx</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ky</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="c1"># evaluate the interpolator: </span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">bisplev</span><span class="p">(</span><span class="n">xinterp</span><span class="p">,</span> <span class="n">yinterp</span><span class="p">,</span> <span class="n">tck</span><span class="p">)</span>

<span class="c1"># Now PLOT!</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span> <span class="c1"># if we want a 3D plot</span>

<span class="c1"># necessary for 2-D plot:</span>
<span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xinterp</span><span class="p">,</span> <span class="n">yinterp</span><span class="p">)</span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

<span class="c1"># plot the data:</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">,</span> <span class="n">zdata</span><span class="p">,</span>  <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">48</span><span class="p">)</span>

<span class="c1"># plot a wireframe of the interpolator:</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot_wireframe</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">rstride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">cstride</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;mpl_toolkits.mplot3d.art3d.Line3DCollection at 0x1322a4410&gt;
</pre></div>
</div>
<img alt="../_images/e197acff8c453a96f927de34ef9ff96e3d2839b7da7f4ac6aab57f9b07609640.png" src="../_images/e197acff8c453a96f927de34ef9ff96e3d2839b7da7f4ac6aab57f9b07609640.png" />
</div>
</div>
</section>
</section>
<section id="least-squares-fitting">
<h2>Least-Squares Fitting<a class="headerlink" href="#least-squares-fitting" title="Link to this heading">#</a></h2>
<p>Within the context of data fitting, it is important to emphasize three points:</p>
<ol class="arabic simple">
<li><p>If the data being fit contains errors, the “best-fit”, in a statistical sense, should not pass through all the data points.</p></li>
<li><p>If the theory is not an appropriate one for the data, then its best fit to the data may not be a good fit at all. This is how we know that the theory is not right.</p></li>
<li><p>Only for the simplest case of a <em>linear</em> least-squares fit can we write down a closed-form solution to evaluate and obtain the fit. More realistic problems are usually solbed by trial-and-error search procedures.</p></li>
</ol>
<p>Imagine that you measured <span class="math notranslate nohighlight">\(N_D\)</span> data values of the dependent variable <span class="math notranslate nohighlight">\(y\)</span> as a function of the independent variable <span class="math notranslate nohighlight">\(x\)</span>:</p>
<p><span class="math notranslate nohighlight">\((x_i, y_i \pm \sigma_i)\)</span>; <span class="math notranslate nohighlight">\(i=1,...,N_D\)</span>,</p>
<p>where <span class="math notranslate nohighlight">\(\pm \sigma_i\)</span> is the experimental uncertainty in the <span class="math notranslate nohighlight">\(i\)</span>-th value of <span class="math notranslate nohighlight">\(y\)</span>.</p>
<p>For simplicity we will assume that errors occur in the dependent variable (<span class="math notranslate nohighlight">\(y\)</span>), altghough this is hardly ever true.</p>
<p><strong>Our goal</strong>: to determine how well a mathematical function <span class="math notranslate nohighlight">\(y=g(x)\)</span> (i.e. the theory or model) can describe the data.</p>
<p>Additionally: if the theory contains some parameters or constants, our goal can be viewed as determining the best values for these.</p>
<p>Therefore, we assume that the theory function <span class="math notranslate nohighlight">\(g(x)\)</span>, contains in addition to the functional dependence on <span class="math notranslate nohighlight">\(x\)</span>, an additional dependence on <span class="math notranslate nohighlight">\(N_P\)</span> parameters: <span class="math notranslate nohighlight">\({a_1, ..., a_{N_P}}\)</span>. These are <em>not</em> variables, but rather parts of the theoretical model.</p>
<p>With these parameters, we can write the function as:</p>
<p><span class="math notranslate nohighlight">\(g(x) = g(x; \{a_1, a_2, ... , a_{N_P}\}) = g(x;\{a_m\})\)</span>, <span class="math notranslate nohighlight">\(m=1,...,N_P\)</span>,</p>
<p>where <span class="math notranslate nohighlight">\(\{a_m\}\)</span> is the set of parameters (<span class="math notranslate nohighlight">\(m=1,...,N_P\)</span>) and <span class="math notranslate nohighlight">\(x\)</span> is the independent variable.</p>
<p>Statistics tells us that we can use the so-called “chi-square” variable as a gauge of how well a theoretical function <span class="math notranslate nohighlight">\(g\)</span> reproduces the data:</p>
<p><span class="math notranslate nohighlight">\( \chi^2 = \sum_{i=1}^{N_D} \left( \frac{ y_i - g(x_i;\{a_m\}) } { \sigma_i } \right)^2\)</span>,</p>
<p>where the sum <span class="math notranslate nohighlight">\(i\)</span> is taken over the <span class="math notranslate nohighlight">\(N_D\)</span> experimental data points <span class="math notranslate nohighlight">\((x_i, y_i \pm \sigma_i)\)</span>.</p>
<p>Smaller values of <span class="math notranslate nohighlight">\(\chi^2\)</span> imply better fits, with <span class="math notranslate nohighlight">\(\chi^2\)</span> occurring if the theoretical curve went through the center of every data point (which never happens in practice!).</p>
<p>The <span class="math notranslate nohighlight">\(1/\sigma_i^2\)</span> weighting results in measurements with larger errors contributing less to <span class="math notranslate nohighlight">\(\chi^2\)</span>.</p>
<p><em>Least-squares fitting</em> involves adjusting the parameters <span class="math notranslate nohighlight">\(\{a_m\}\)</span> (<span class="math notranslate nohighlight">\(m=1,...,N_P\)</span>) until a <em>minimum</em> <span class="math notranslate nohighlight">\(\chi^2\)</span> is found.</p>
<p>This is the best fit possible, and the best way to determine the parameters in a theory.</p>
<p>Therefore, the <span class="math notranslate nohighlight">\(N_P\)</span> parameters <span class="math notranslate nohighlight">\(\{a_m\}\)</span> that make the <span class="math notranslate nohighlight">\(\chi^2\)</span> an extremum are found by solving the <span class="math notranslate nohighlight">\(N_P\)</span> equations:</p>
<p><span class="math notranslate nohighlight">\(\frac{ \partial \chi^2 }{ \partial a_m } = 0\)</span>; <span class="math notranslate nohighlight">\(m=1,...,N_P\)</span>,</p>
<p>which imply that:</p>
<p><span class="math notranslate nohighlight">\(\sum_{i=1}^{N_D} \frac{ [y_i - g(x_i;\{a_m\})] } { \sigma_i^2 }\frac{ \partial g(x_i) }{ \partial a_m } = 0\)</span>, <span class="math notranslate nohighlight">\(m=1,...,N_P\)</span>.</p>
<p>Often <span class="math notranslate nohighlight">\(g(x;\{a_m\})\)</span> has a sufficiently complicated dependence on the values of the <span class="math notranslate nohighlight">\(\{a_m\}\)</span> parameters to produce <span class="math notranslate nohighlight">\(N_P\)</span> <em>simultaneous nonlinear</em> equations for the <span class="math notranslate nohighlight">\(\{a_m\}\)</span> values.</p>
<p>But we already know how to solve these! (Trial-and-error searching through the <span class="math notranslate nohighlight">\(N_p\)</span>-dimensional parameter space).</p>
<p>To be safe, when such a search is completed, you need to check that the minimum of <span class="math notranslate nohighlight">\(\chi^2\)</span> is a global one and not a local one. One way to do this is to repeat the search for a whole grid of starting values, and if different minima are found, to pick the one with the lowest <span class="math notranslate nohighlight">\(\chi^2\)</span>.</p>
<p>When the deviations from theory are a result of random errors described by Gaussian distributions, there are some useful rules of thumb to remember:</p>
<ul class="simple">
<li><p>You know your fit is good if the value of <span class="math notranslate nohighlight">\(\chi^2\)</span> calculated is approximately equal to the number of degrees of freedom, i.e. <span class="math notranslate nohighlight">\(\chi^2 \simeq N_D - N_P\)</span>, the difference between the number of data points and the number of parameters in your theory function.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(\chi^2 \ll N_D - N_P\)</span>, it does not mean you have a great theory or a really precise measurement; instead, you probably have <em>too many parameters</em> or have assigned errors (<span class="math notranslate nohighlight">\(\sigma_i\)</span>) that are too large (i.e. you <em>overestimated</em> the errors).</p></li>
<li><p>if <span class="math notranslate nohighlight">\(\chi^2 \gg N_D - N_P\)</span>, the theory may not be good, or you may have significantly <em>underestimated</em> your errors, or you may have errors that are not random.</p></li>
</ul>
<section id="linear-regression">
<h3>Linear Regression<a class="headerlink" href="#linear-regression" title="Link to this heading">#</a></h3>
<p>The <span class="math notranslate nohighlight">\(N_P\)</span> simultaneous equations can be simplified considerably if the functions <span class="math notranslate nohighlight">\(g(x;\{a_m\}\)</span> depend <em>linearly</em> on the parameter values <span class="math notranslate nohighlight">\(a_m\)</span>, e.g.:</p>
<p><span class="math notranslate nohighlight">\(g(x; a_1, a_2) = a_1 + a_2 x\)</span>.</p>
<p>In this case, known as “linear regression”, there are two parameters: the slope <span class="math notranslate nohighlight">\(a_2\)</span> and the <span class="math notranslate nohighlight">\(y\)</span>-intercept <span class="math notranslate nohighlight">\(a_1\)</span>.</p>
<p>Notice that, while there are only two parameters to determine, there still may be an arbitrary number of <span class="math notranslate nohighlight">\(N_D\)</span> data points to fit.</p>
<p><em>Remember</em>: A unique solution <em>is not possible</em> unless the number of data points is greater than the number of parameters: <span class="math notranslate nohighlight">\(N_D \geq N_P\)</span>.</p>
<p>For the linear case, there are only two derivatives to consider:</p>
<p><span class="math notranslate nohighlight">\(\frac{ \partial g } { \partial a_1 } = 1\)</span>, <span class="math notranslate nohighlight">\(\frac{ \partial g } { \partial a_2 } = x\)</span>.</p>
<p>After substitution, the <span class="math notranslate nohighlight">\(\chi^2\)</span> minimization equations can be solved:</p>
<p><span class="math notranslate nohighlight">\(a_1 = \frac{ S_{xx} S_y - S_x S_{xy} }{\Delta}\)</span>, <span class="math notranslate nohighlight">\(a_2 = \frac{S S_{xy} - S_x S_y}{\Delta}\)</span>, where:</p>
<p><span class="math notranslate nohighlight">\(S = \sum_{i=1}^{N_D} \frac{1}{\sigma_i^2}\)</span>,</p>
<p><span class="math notranslate nohighlight">\(S_x = \sum_{i=1}^{N_D} \frac{x_i}{\sigma_i^2}\)</span>,</p>
<p><span class="math notranslate nohighlight">\(S_y = \sum_{i=1}^{N_D} \frac{y_i}{\sigma_i^2}\)</span>,</p>
<p><span class="math notranslate nohighlight">\(S_{xx} = \sum_{i=1}^{N_D} \frac{x_i^2}{\sigma_i^2}\)</span>,</p>
<p><span class="math notranslate nohighlight">\(S_{xy} = \sum_{i=1}^{N_D} \frac{x_i y_i}{\sigma_i^2}\)</span>,</p>
<p><span class="math notranslate nohighlight">\(\Delta = S S_{xx} - S_x^2\)</span>.</p>
<p>You can also get an expression for the variance (the square of the uncertainty) in the deduced parameters:</p>
<p><span class="math notranslate nohighlight">\(\sigma_{a_1}^2 = \frac{ S_{xx}}{\Delta}\)</span>, <span class="math notranslate nohighlight">\(\sigma_{a_2} = \frac{S}{\Delta}\)</span>.</p>
<p>This is a measure of the uncertainties in the values of the fitted parameters, arising from the uncertainties <span class="math notranslate nohighlight">\(\sigma_i\)</span> in the measured <span class="math notranslate nohighlight">\(y_i\)</span> values.</p>
<p>A measure of the dependence of the parameters on each other is given by the <em>correlation coefficient</em>:</p>
<p><span class="math notranslate nohighlight">\(\rho(a_1, a_2) = \frac{ \mathrm{cov}(a_1, a_2) }{ \sigma_{a_1} \sigma_{a_2} }\)</span>, where:</p>
<p><span class="math notranslate nohighlight">\(\mathrm{cov}(a_1, a_2) = \frac{ - S_x } { \Delta }\)</span> is the covariance between <span class="math notranslate nohighlight">\(a_1\)</span> and <span class="math notranslate nohighlight">\(a_2\)</span>.</p>
<p>The above analytic solutions  for the parametrs are of the form found in statistics textbooks, but are n ot optimal for numerical calculations: subtractive cancelation can make the answers unstable. As previously discussed, a rearrangement of the equations can decrease this kind of error.</p>
<p>An improved set of expressions is given by:</p>
<p><span class="math notranslate nohighlight">\(a_1 = \bar{y} - a_2 \bar{x}\)</span>, <span class="math notranslate nohighlight">\(a_2 = \frac{ S_{xy} } { S_{xx} }\)</span>, <span class="math notranslate nohighlight">\(\bar{x} = \frac{1}{N} \sum_{i=1}^{N_D} x_i\)</span>, <span class="math notranslate nohighlight">\(\bar{y} = \frac{1}{N} \sum_{i=1}^{N_D} y_i\)</span>, <span class="math notranslate nohighlight">\(S_{xy} = \sum_{i=1}^{N_D} \frac{(x_i - \bar{x}) (y_i - \bar{y})}{\sigma_i^2}\)</span>, <span class="math notranslate nohighlight">\(S_{xx} = \sum_{i=1}^{N_D} \frac{(x_i - \bar{x})^2}{\sigma_i^2}\)</span></p>
</section>
<section id="example-6-11-hubble-s-law">
<h3>Example 6.11: Hubble’s Law<a class="headerlink" href="#example-6-11-hubble-s-law" title="Link to this heading">#</a></h3>
<p>In 1929, Edwin Hubble examined the data related the radial velocity <span class="math notranslate nohighlight">\(v\)</span> of 24 extra-galactic nebulae, to their distance <span class="math notranslate nohighlight">\(r\)</span> from our galaxy. He fit them with a straight line:</p>
<p><span class="math notranslate nohighlight">\( v = Hr\)</span>, where <span class="math notranslate nohighlight">\(H\)</span> is now known as the Hubble constant.</p>
<p>His measurements are given in the file <code class="docutils literal notranslate"><span class="pre">hubble.txt</span></code>, where the first column represents the distance <span class="math notranslate nohighlight">\(r\)</span> in Mpc (pc=parsec, defined as the distance at which 1 astronomical unit, the mean Earth-sun distance, subtends an angle of one arcsecond, i.e. 1/3600 of a degree), and the second column is the velocity <span class="math notranslate nohighlight">\(v\)</span> in km/s.</p>
<p>We will assume that the errors on <span class="math notranslate nohighlight">\(v\)</span> are <span class="math notranslate nohighlight">\(\sigma =1~\mathrm{km/s}\)</span>, but we will re-evaluate this assumption later on.</p>
<p>a) Load the file using <code class="docutils literal notranslate"><span class="pre">pandas</span></code> and plot the data using <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code>.</p>
<p>b) Compute the least-squares straight-line fit to the data in the form:</p>
<p><span class="math notranslate nohighlight">\(v(r) = a + Hr\)</span>,</p>
<p>including the errors on the parameters, <span class="math notranslate nohighlight">\(\sigma_a\)</span> and <span class="math notranslate nohighlight">\(\sigma_H\)</span>.</p>
<p>c) Plot your best fit along with the data.</p>
<p>d) Determine the <span class="math notranslate nohighlight">\(\chi^2\)</span> of the fit. Given its value, what would a better estimate of the average error on the measurements be?</p>
</section>
<section id="quadratic-fits">
<h3>Quadratic Fits<a class="headerlink" href="#quadratic-fits" title="Link to this heading">#</a></h3>
<p>As long as the function being fitted depends <em>linearly</em> on the unknown parameters <span class="math notranslate nohighlight">\(a_i\)</span>, the condition of minimum <span class="math notranslate nohighlight">\(\chi^2\)</span> leads to a set of simultaneous <em>linear</em> equations for the <span class="math notranslate nohighlight">\(a_m\)</span>’s that can be solved by hand or on a computer using matrix techniques. This is true if the function being fitted is a polynomial of any degree.</p>
<p>E.g. suppose we want to fit the quadratic polynomial:</p>
<p><span class="math notranslate nohighlight">\(g(x) = a_1 + a_2 x + a_3 x^2\)</span>,</p>
<p>to the experimental measurements <span class="math notranslate nohighlight">\((x_i, y_i \pm \sigma_i)\)</span>, <span class="math notranslate nohighlight">\(i=1,...,N_D\)</span>.</p>
<p>Here, <span class="math notranslate nohighlight">\(g(x)\)</span> is linear in all the parameters <span class="math notranslate nohighlight">\(a_m\)</span>, and we still only need to solve linear simultaneous equations, even though <span class="math notranslate nohighlight">\(x\)</span> is raised to the second power.</p>
<p><em>In contrast</em>, if we were trying to fit a function of the form <span class="math notranslate nohighlight">\(g(x) = (a_1 + a_2) e^{-a_3 x}\)</span> to the data, then we would need to solve nonlinear simultaneous equations (see next subsection).</p>
<p>The best fit of a quadratic to the data is obtained by applying the minimum <span class="math notranslate nohighlight">\(\chi^2\)</span> condition for <span class="math notranslate nohighlight">\(N_P = 3\)</span> parameters and <span class="math notranslate nohighlight">\(N_D\)</span> data points.</p>
<p><span class="math notranslate nohighlight">\(\frac{ \partial \chi^2 } { \partial a_m }\)</span>, <span class="math notranslate nohighlight">\(m=1,2,3\)</span> leads to three simultaneous linear equations for <span class="math notranslate nohighlight">\(a_1\)</span>, <span class="math notranslate nohighlight">\(a_2\)</span> and <span class="math notranslate nohighlight">\(a_3\)</span>:</p>
<p><span class="math notranslate nohighlight">\(\sum_{i=1}^{N_D} \frac{ [y_i - g(x_i;\{a_m\})] } { \sigma_i^2 }\frac{ \partial g(x_i) }{ \partial a_m } = 0\)</span>, <span class="math notranslate nohighlight">\(m=1,2,3\)</span>, with:</p>
<p><span class="math notranslate nohighlight">\(\frac{ \partial g } { \partial a_1 } = 1\)</span>, <span class="math notranslate nohighlight">\(\frac{ \partial g } { \partial a_2 } = x\)</span>, <span class="math notranslate nohighlight">\(\frac{ \partial g } { \partial a_3 } = x^2\)</span>.</p>
<p>The <span class="math notranslate nohighlight">\(a_m\)</span> dependence only arises from the term in the square brackets in the sums. Since that term only has a linear dependence on the <span class="math notranslate nohighlight">\(a_m\)</span>’s, all the equations are linear in them.</p>
<p>The equations can be written as:</p>
<p><span class="math notranslate nohighlight">\(S a_1 + S_x a_2 + S_{xx} a_3 = S_y\)</span>,</p>
<p><span class="math notranslate nohighlight">\(S_x a_1 + S_{xx} a_2 + S_{xxx} a_3 = S_{xy}\)</span>,</p>
<p><span class="math notranslate nohighlight">\(S_{xx} a_1 + S_{xxx} a_2 + S_{xxxx} a_3 = S_{xxy}\)</span>.</p>
<p>with <span class="math notranslate nohighlight">\(S = \sum_{i=1}^{N_D} \frac{1}{\sigma_i^2}\)</span>, <span class="math notranslate nohighlight">\(S_x = \sum_{i=1}^{N_D} \frac{x_i}{\sigma_i^2}\)</span>, <span class="math notranslate nohighlight">\(S_y = \sum_{i=1}^{N_D} \frac{y_i}{\sigma_i^2}\)</span>, <span class="math notranslate nohighlight">\(S_{xx} = \sum_{i=1}^{N_D} \frac{x_i^2}{\sigma_i^2}\)</span>, <span class="math notranslate nohighlight">\(S_{xy} = \sum_{i=1}^{N_D} \frac{x_i y_i}{\sigma_i^2}\)</span>, and so on.</p>
<p>If we now define the vector of unknowns:</p>
<p><span class="math notranslate nohighlight">\(\vec{a} = \left(\begin{array}{c} 
a_{1}  \\
a_{2}  \\
a_{3} 
\end{array}\right)\)</span>,</p>
<p>the matrix:</p>
<p><span class="math notranslate nohighlight">\(\mathbf{A} = \left(\begin{array}{c} 
S &amp; S_x &amp; S_{xx}  \\
S_x &amp; S_{xx} &amp; S_{xxx}  \\
S_{xx} &amp; S_{xxx} &amp; S_{xxxx}  
\end{array}\right)\)</span>,</p>
<p>and:</p>
<p><span class="math notranslate nohighlight">\(\vec{b} = \left(\begin{array}{c} 
S_y  \\
S_{xy}  \\
S_{xxy} 
\end{array}\right)\)</span>,</p>
<p>then to get the coefficients <span class="math notranslate nohighlight">\(a_1, a_2, a_3\)</span>, we need to solve the matrix equation:</p>
<p><span class="math notranslate nohighlight">\(\mathbf{A} \vec{a} = \vec{b}\)</span>, for <span class="math notranslate nohighlight">\(\vec{a}\)</span>, using the techniques that we have previously discussed in this chapter.</p>
</section>
<section id="nonlinear-fitting">
<h3>Nonlinear Fitting<a class="headerlink" href="#nonlinear-fitting" title="Link to this heading">#</a></h3>
<p>Earlier in this section we saw the Breit-Wigner resonance formula:</p>
<p><span class="math notranslate nohighlight">\(f(E) = \frac{ f_r } { (E-E_r)^2 + \Gamma^2 / 4 }\)</span>.</p>
<p>If we have a set of data that we wish to describe with such a formula, we would need to determine what values for the parameters <span class="math notranslate nohighlight">\(E_r\)</span>, <span class="math notranslate nohighlight">\(f_r\)</span> and <span class="math notranslate nohighlight">\(\Gamma\)</span> provide the best fit to the data.</p>
<p>Since <span class="math notranslate nohighlight">\(f\)</span> is a nonlinear function of the parameters, the equations that result from minimizing <span class="math notranslate nohighlight">\(\chi^2\)</span> are <em>nonlinear</em> as well!</p>
<p>But we already saw how to use the Newton-Raphson algorithm to search for solutions of simultaneous nonlinear equations. The method involved an expansion of the equations about the previous “guess” point, to obtain a set of linear equations, and then solving the linear equations with matrix libraries.</p>
<p>In what follows, we will use the same combination of fitting, trial-and-error searching and matrix algebra, to conduct a nonlinear least-squares fit to the data.</p>
<p>To get the best fit, we need t ofind values of the <span class="math notranslate nohighlight">\(N_P\)</span> parameters <span class="math notranslate nohighlight">\(a_m\)</span> in the theory <span class="math notranslate nohighlight">\(g(x; \{a_m\})\)</span> that minimize:</p>
<p><span class="math notranslate nohighlight">\(\chi^2 = \sum_{i=1}^{N_D} \left( \frac{ y - y_i }{\sigma_i}\right)^2\)</span>.</p>
<p>This leads to the <span class="math notranslate nohighlight">\(N_P\)</span> equations:</p>
<p><span class="math notranslate nohighlight">\(\sum_{i=1}^{N_D} \frac{ [y_i - g(x_i; \{a_n\})] } { \sigma_i^2 } \frac{ \partial g(x_i; \{a_n\}) }{ \partial a_m }  = 0\)</span>, <span class="math notranslate nohighlight">\(m=1,...,N_P\)</span>.</p>
<p>For the sake of simplicity, let’s rewrite the theory function using the redefinitions:</p>
<p><span class="math notranslate nohighlight">\(f_r \rightarrow a_1\)</span>, <span class="math notranslate nohighlight">\(E_r \rightarrow a_2\)</span>, <span class="math notranslate nohighlight">\(\Gamma^2/4 \rightarrow a_3\)</span>, <span class="math notranslate nohighlight">\(E\rightarrow x\)</span> such that:</p>
<p><span class="math notranslate nohighlight">\(g(x; a_1, a_2, a_3) = \frac{ a_1 } { (x-a_2)^2 + a_3 }\)</span>.</p>
<p>The derivatives required are then:</p>
<p><span class="math notranslate nohighlight">\(\frac{ \partial g } { \partial a_1 } = \frac{ 1 } { (x-a_2)^2 + a_3 }\)</span>, <span class="math notranslate nohighlight">\(\frac{ \partial g } { \partial a_2 } = \frac{ -2 a_1 (x - a_2) }{[ (x-a_2)^2 + a_3]}\)</span>, <span class="math notranslate nohighlight">\(\frac{ \partial g } { \partial a_3 } =  \frac{ -a_1 } { [ (x-a_2)^2 + a_3]^2}\)</span>.</p>
<p>Substituting into the best-fit condition yields three simultaneous nonlinear equations in <span class="math notranslate nohighlight">\(a_1, a_2, a_3\)</span> that we need to solve in order to fit the <span class="math notranslate nohighlight">\(N_D\)</span> data points.</p>
<p>If all the errors are equal, we then have the following equations in the form that we require for the Newton-Raphson method, i.e. <span class="math notranslate nohighlight">\(f_i(a_1, a_2, ..., a_N) = 0\)</span>, <span class="math notranslate nohighlight">\(i=1,...,N\)</span>:</p>
<p><span class="math notranslate nohighlight">\(f_1(a_1, a_2, a_3) = \sum_{i=1}^9 \frac{ y_i - g(x_i; a_1, a_2, a_3) } { (x_i - a_2)^2 + a_3 } = 0\)</span>,</p>
<p><span class="math notranslate nohighlight">\(f_2(a_1, a_2, a_3) = \sum_{i=1}^9 \frac{ [y_i - g(x_i; a_1, a_2, a_3)] (x_i - a_2) } { [(x_i - a_2)^2 + a_3]^2 } = 0\)</span>,</p>
<p><span class="math notranslate nohighlight">\(f_3(a_1, a_2, a_3) = \sum_{i=1}^9 \frac{ y_i - g(x_i; a_1, a_2, a_3) } { [(x_i - a_2)^2 + a_3]^2 } = 0\)</span></p>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./Chapters"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="Chapter5.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Introduction</p>
      </div>
    </a>
    <a class="right-next"
       href="Chapter7.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Introduction</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#">Trial-and-Error Root Finding</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#introduction">Introduction</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#trial-and-error-roots-via-bisection">Trial-and-error Roots via Bisection</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-6-1-temperature-dependence-of-magnetization">Example 6.1: Temperature Dependence of Magnetization.</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#newton-raphson-searching">Newton-Raphson Searching</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#newton-raphson-with-backtracking">Newton-Raphson with Backtracking</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-6-2-newton-raphson-applied-to-the-temperature-dependence-of-magnetization">Example 6.2: Newton-Raphson applied to the Temperature Dependence of Magnetization.</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#matrix-computing">Matrix Computing</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#why-matrix-computing">Why Matrix Computing?</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#classes-of-matrix-problems">Classes of Matrix Problems</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#math-recap-matrix-multiplication-inverses-and-determinants">Math Recap: Matrix Multiplication, Inverses and Determinants</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-6-3-in-this-problem-we-will-find-the-inverse-of-a-3x3-matrix-analytically-and-show-via-direct-matrix-multiplication-that-it-indeed-gives-back-the-identity-matrix">Example 6.3: In this problem we will find the inverse of a 3x3 matrix <em>analytically</em> and show via direct matrix multiplication that it indeed gives back the identity matrix.</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#math-recap-solving-eigenvalue-problems">Math Recap: Solving Eigenvalue Problems</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-6-4-find-the-eigenvalues-and-eigenvectors-of-the-matrix">Example 6.4: Find the eigenvalues and eigenvectors of the matrix:</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-6-5-given-that-lambda-1-5-is-an-eigenvalue-find-the-remaining-eigenvalues-of-the-matrix">Example 6.5: Given that <span class="math notranslate nohighlight">\(\lambda_1 = 5\)</span> is an eigenvalue, find the remaining eigenvalues of the matrix:</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#practical-matrix-computing">Practical Matrix Computing</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#matrices-in-python-python-lists-numpy-arrays">Matrices in Python: Python Lists, NumPy Arrays</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#python-lists">Python Lists</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#numpy-arrays">NumPy Arrays</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#numpy-s-linalg-package">NumPy’s linalg Package</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-6-6-solve-examples-6-3-to-6-5-numerically">Example 6.6: Solve Examples 6.3 to 6.5 numerically!</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#n-dimensional-newton-raphson">N-Dimensional Newton-Raphson</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#more-matrix-examples">More Matrix Examples</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-6-6-your-model-of-some-physical-system-results-in-n-100-coupled-linear-equations-with-n-unknowns">Example 6.6: Your model of some physical system results in <span class="math notranslate nohighlight">\(N=100\)</span> coupled linear equations with <span class="math notranslate nohighlight">\(N\)</span> unknowns:</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-6-7-dirac-gamma-matrices">Example 6.7: Dirac Gamma Matrices</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#data-fitting">Data Fitting</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#lagrange-interpolation">Lagrange Interpolation</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-6-8-lagrange-interpolation">Example 6.8: Lagrange Interpolation</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#cubic-spline-interpolation">Cubic Spline Interpolation</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-6-9-cubic-spline-interpolation-with-scipy">Example 6.9: Cubic Spline Interpolation with scipy</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#other-scipy-interpolators">Other SciPy Interpolators</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-6-10-global-temperature-load-data-with-pandas-and-interpolate-with-scipy">Example 6.10: Global Temperature: Load data with Pandas and Interpolate with SciPy</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#d-interpolation">2-D Interpolation</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#least-squares-fitting">Least-Squares Fitting</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#linear-regression">Linear Regression</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-6-11-hubble-s-law">Example 6.11: Hubble’s Law</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#quadratic-fits">Quadratic Fits</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nonlinear-fitting">Nonlinear Fitting</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Andreas Papaefstathiou
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>