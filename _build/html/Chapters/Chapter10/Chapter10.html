
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>10. Partial Differential Equations &#8212; Computational Physics I (PHYS 3500K)</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.1/css/all.min.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.1/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.1/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.1/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=384b581d" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae" />
  <script src="../../_static/vendor/fontawesome/6.5.1/js/all.min.js?digest=8d27b9dea8ad943066ae"></script>

    <script src="../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=efea14e4"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=36754332"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'Chapters/Chapter10/Chapter10';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="prev" title="9. Boundary Value and Eigenvalue Problems" href="../Chapter9/Chapter9.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a id="pst-skip-link" class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <header class="bd-header navbar navbar-expand-lg bd-navbar">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="../../intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/d2lbanner2.png" class="logo__image only-light" alt="Computational Physics I (PHYS 3500K) - Home"/>
    <script>document.write(`<img src="../../_static/d2lbanner2.png" class="logo__image only-dark" alt="Computational Physics I (PHYS 3500K) - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../intro.html">
                    Computational Physics I - PHYS 3500K
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../Chapter1/Chapter1.html">1. Hello Whimsical World of Pythonic Physics!</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter2/Chapter2.html">2. To err is human, to really foul things up requires a computer!</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter3/Chapter3.html">3. Randomness and Random Walks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter4/Chapter4.html">4. Numerical Differentiation and Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter5/Chapter5.html">5. Monte Carlo Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter6/Chapter6.html">6. Matrix Computing, Trial-and-Error Searching and Data Fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter7/Chapter7.html">7. Ordinary Differential Equations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter8/Chapter8.html">8. An Introduction to Nonlinear Dynamics and Chaos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter9/Chapter9.html">9. Boundary Value and Eigenvalue Problems</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">10. Partial Differential Equations</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/executablebooks/jupyter-book" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/executablebooks/jupyter-book/issues/new?title=Issue%20on%20page%20%2FChapters/Chapter10/Chapter10.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/Chapters/Chapter10/Chapter10.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Partial Differential Equations</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#introduction">10.1. Introduction</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#elliptic-partial-differential-equations">10.2. Elliptic Partial Differential Equations</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#discretization">10.2.1. Discretization</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#variational-principle-approach">10.2.2. Variational Principle Approach</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#an-iterative-method-for-boundary-value-problems">10.2.3. An Iterative Method for Boundary Value Problems</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-10-1-the-relaxation-method-for-partial-differential-equations-in-one-dimension">10.2.4. Example 10.1: The relaxation method for partial differential equations in one dimension.</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-relaxation-method-in-higher-dimensions">10.2.5. The Relaxation Method in Higher Dimensions</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#parabolic-partial-differential-equations">10.3. Parabolic Partial Differential Equations</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#naive-discretization-and-instabilities">10.3.1. Naive Discretization and Instabilities</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-10-2-parabolic-pdes-a-first-example">10.3.2. Example 10.2: Parabolic PDEs: a first example</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#implicit-schemes">10.3.3. Implicit Schemes</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-10-3-application-of-the-implicit-scheme-for-parabolic-pdes">10.3.4. Example 10.3: Application of the Implicit Scheme for Parabolic PDEs</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#solution-by-direct-matrix-multiplication">10.3.5. Solution by Direct Matrix Multiplication</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="partial-differential-equations">
<h1><span class="section-number">10. </span>Partial Differential Equations<a class="headerlink" href="#partial-differential-equations" title="Link to this heading">#</a></h1>
<section id="introduction">
<h2><span class="section-number">10.1. </span>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">#</a></h2>
<p>Partial differential equations (PDEs) are involved in the description of virtually every physical situation where quantities vary in space, or in space and time.</p>
<p>Examples are diffusion, electromagnetic waves, hydrodynamics, quantum mechanics.</p>
<p>In all but the simplest cases, equations cannot be solved analytically, and so numerical methods must be employed for quantitative results.</p>
<p>The typical numerical approach proceeds as follows: the dependent variables (e.g. temperature, electrical potential), are described by their values at discrete points (a lattice) of the independent variables (e.g. space and time).</p>
<p>Therefore, by appropriate discretization, the PDE is reduced to a large set of <em>difference equations</em>.</p>
<p>Although difference equations can be solved by matrix methods, the large size of the matrices involved (dimension <span class="math notranslate nohighlight">\(\sim\)</span> number of lattice points), makes this approach impractical.</p>
<p>However, the locality of the original equations (i.e. they involved only low-order derivatives of the dependent variables) makes the resulting differential equations “sparse”, which implies that most of the elements of the matrices involved vanish.</p>
<p>For such matrices, iterative methods of inversion and diagonalization can be very efficient.</p>
<p>Most of the physically important PDEs are of second order and can be classified into three types:</p>
<ol class="arabic simple">
<li><p><em>Parabolic:</em> Roughly speaking, parabolic equations involve only a first-order derivative in one variable, but have second-order derivatives in the remaining variables. Examples the diffusion equation, or the time-dependent Schrödinger equation: they are first order in time, but second order in space.</p></li>
<li><p><em>Elliptic:</em> They have second order derivatives in each of the independent variables, each derivative having the <em>same sign</em> when all terms of the equation are grouped on one side. Examples are the Poisson equation for the electrical potential and the time-independent Schrödinger equation, in two or more spatial variables.</p></li>
<li><p><em>Hyperbolic:</em> They involve second derivatives of opposite sign, e.g. the wave equation describing the vibrations of a stretched string.</p></li>
</ol>
<p>In this chapter, we will discuss some numerical methods appropriate for <em>elliptic</em> equations and then focus on <em>parabolic</em> equations. Hyperbolic equations often can be treated by similar methods, with some unique differences (we won’t discuss these here).</p>
</section>
<section id="elliptic-partial-differential-equations">
<h2><span class="section-number">10.2. </span>Elliptic Partial Differential Equations<a class="headerlink" href="#elliptic-partial-differential-equations" title="Link to this heading">#</a></h2>
<p>For concreteness, we will consider particular forms of elliptic boundary value and eigenvalue problems for a field <span class="math notranslate nohighlight">\(\phi\)</span> in two spatial dimensions, <span class="math notranslate nohighlight">\((x,y)\)</span>.</p>
<p>Specifically, we will tackle the boundary value problem:</p>
<p><span class="math notranslate nohighlight">\(-\left[ \frac{\partial^2}{\partial x^2} + \frac{\partial^2}{\partial y^2}\right] \phi = S(x,y)\)</span>.</p>
<p>Although this is not the most general elliptic form, it covers a wide variety of situations. For example, in electrostatics, <span class="math notranslate nohighlight">\(\phi\)</span> is the potential and <span class="math notranslate nohighlight">\(S\)</span> is related to the charge density (i.e., it is a source term). In steady-state heat diffusion, <span class="math notranslate nohighlight">\(\phi\)</span> is the temperature, <span class="math notranslate nohighlight">\(S\)</span> is the local rate of heat generation or loss.</p>
<p>The discussion can be generalized straightforwardly to other elliptic cases, e.g. in three dimensions.</p>
<p>Of course, the equation by itself is not complete. The boundary conditions are required. We will take the boundary conditions to be of the “Dirichlet” type, i.e. <span class="math notranslate nohighlight">\(\phi\)</span> is specified on some closed curve on the <span class="math notranslate nohighlight">\((x,y)\)</span> plane. Conveniently, we will take this to be the unit square, and perhaps some additional curves within it.</p>
<p>The boundary value problem is then to use the PDE to find <span class="math notranslate nohighlight">\(\phi\)</span> everywhere within the square.</p>
<p>Other classes of boundary conditions are the “Neumann” type, where the normal derivative of <span class="math notranslate nohighlight">\(\phi\)</span> is specified on the surfaces, or the “mixed” type, where a linear combination of <span class="math notranslate nohighlight">\(\phi\)</span> and its normal derivatives is specified. Both can be handled by very similar methods.</p>
<p>The eigenvalue problems we will be interested in might involve an equation of the form,</p>
<p><span class="math notranslate nohighlight">\(-\left[ \frac{\partial^2}{\partial x^2} + \frac{\partial^2}{\partial y^2}\right] \phi + V(x,y)\phi = \varepsilon \phi\)</span>,</p>
<p>together with a set of Dirichlet boundary conditions.</p>
<p>As an example, the above could be the time-independent Schrödinger equation, with <span class="math notranslate nohighlight">\(\phi\)</span> being the wave function, <span class="math notranslate nohighlight">\(V(x,y)\)</span> is related to the potential and <span class="math notranslate nohighlight">\(\varepsilon\)</span> is related to the energy eigenvalue.</p>
<p>The eigenvalue problem is then to find the values <span class="math notranslate nohighlight">\(\varepsilon_\lambda\)</span> and the associated eigenfunctions <span class="math notranslate nohighlight">\(\phi_\lambda\)</span>, for which the equation and the b.c.’s are satisfied.</p>
<section id="discretization">
<h3><span class="section-number">10.2.1. </span>Discretization<a class="headerlink" href="#discretization" title="Link to this heading">#</a></h3>
<p>Let’s first cast the equation:</p>
<p><span class="math notranslate nohighlight">\(-\left[ \frac{\partial^2}{\partial x^2} + \frac{\partial^2}{\partial y^2}\right] \phi = S(x,y)\)</span>.</p>
<p>in a form suitable for numerical treatment.</p>
<p>We define a set of lattice points covering the region of interest in the <span class="math notranslate nohighlight">\((x,y)\)</span> plane.</p>
<p>For convenience, we take the lattice spacing <span class="math notranslate nohighlight">\(h\)</span> to be uniform and equal in both directions. Therefore, the unit square is covered by <span class="math notranslate nohighlight">\(N\times N\)</span> lattice squares, with points labeled by <span class="math notranslate nohighlight">\((i,j)\)</span>, each of which runs from <span class="math notranslate nohighlight">\(0\)</span> to <span class="math notranslate nohighlight">\(N\)</span>. The coordinates of point <span class="math notranslate nohighlight">\((i,j)\)</span> are <span class="math notranslate nohighlight">\(x_i = ih\)</span> and <span class="math notranslate nohighlight">\(y_j = jh\)</span>.</p>
<p>We then define <span class="math notranslate nohighlight">\(\phi_{ij} = \phi(x_i, y_j)\)</span> and <span class="math notranslate nohighlight">\(S_{ij} = S(x_i, y_j)\)</span>.</p>
<p>It is straightforward to apply a three-point difference for the second derivative (see, e.g. Chapter 9, section 2 for a derivation using a Taylor series expansion in one dimension):</p>
<p><span class="math notranslate nohighlight">\(\frac{\partial^2 \phi}{\partial x^2} \simeq \frac{ \phi_{i+1j} + \phi_{i-1j} - 2 \phi_{ij}}{h^2}\)</span>,</p>
<p>to get:</p>
<p><span class="math notranslate nohighlight">\(-\left[\frac{ \phi_{i+1j} + \phi_{i-1j} - 2 \phi_{ij}}{h^2} + \frac{ \phi_{ij+1} + \phi_{ij-1} - 2 \phi_{ij}}{h^2}\right] = S_{ij}\)</span>.</p>
</section>
<section id="variational-principle-approach">
<h3><span class="section-number">10.2.2. </span>Variational Principle Approach<a class="headerlink" href="#variational-principle-approach" title="Link to this heading">#</a></h3>
<p>We will be solving this equation shortly, but first let’s derive it in an alternate way, based on a <em>variational  principle</em>.</p>
<p>This approach is handy in cases where the coordinates are not Cartesian, or when more accurate formulas are needed.</p>
<p>The variational principle also provides some insnight into how the solution algorithm works.</p>
<p>Consider a quantity <span class="math notranslate nohighlight">\(\mathcal{E}\)</span>, defined to be a <em>functional</em> of the field <span class="math notranslate nohighlight">\(\phi\)</span>, of the form:</p>
<p><span class="math notranslate nohighlight">\(\mathcal{E} = \int_0^1 \mathrm{d} x  \int_0^1 \mathrm{d} y \left[ \frac{1}{2} (\nabla \phi)^2 - S \phi \right]\)</span>.</p>
<p>In some situations, <span class="math notranslate nohighlight">\(\mathcal{E}\)</span> has a physical interpretation. For example, in electrostatics, <span class="math notranslate nohighlight">\(E = -\nabla \phi\)</span> is the electric field and <span class="math notranslate nohighlight">\(S\)</span> is the charge density, making <span class="math notranslate nohighlight">\(\mathcal{E}\)</span> the total energy of the system.</p>
<p>In other situations, such as steady-state diffusion, <span class="math notranslate nohighlight">\(\mathcal{E}\)</span> should be viewed simply as a useful quantity.</p>
<p>At a solution to <span class="math notranslate nohighlight">\(-\left[ \frac{\partial^2}{\partial x^2} + \frac{\partial^2}{\partial y^2}\right] \phi = S(x,y)\)</span>, <span class="math notranslate nohighlight">\(\mathcal{E}\)</span> is <em>stationary</em> under all variations of the solution <span class="math notranslate nohighlight">\(\phi\)</span>, called <span class="math notranslate nohighlight">\(\delta \phi\)</span> that respect the Dirichlet boundary conditions imposed.</p>
<p><span class="math notranslate nohighlight">\(\mathcal{E}\)</span> being stationary implies that:</p>
<p><span class="math notranslate nohighlight">\(\delta \mathcal{E} = 0\)</span>.</p>
<p>Let’s find an expression for <span class="math notranslate nohighlight">\(\delta \mathcal{E}\)</span>. The “<span class="math notranslate nohighlight">\(\delta\)</span>” simply acts as any derivative would, and therefore:</p>
<p><span class="math notranslate nohighlight">\(\delta \mathcal{E} = \int_0^1 \mathrm{d} x \int_0^1 \mathrm{d} y \left[ \mathbf{\nabla} \phi \cdot \mathbf{\nabla} \delta \phi - S \delta \phi\right]\)</span>.</p>
<p>To perform the integral of the first term by parts, we need to derive an appropriate integration by parts identity in two dimensions.</p>
<p>Starting with the <em>divergence theorem</em> in two dimensions for a vector field <span class="math notranslate nohighlight">\(\mathbf{V}\)</span>:</p>
<p><span class="math notranslate nohighlight">\(\int_C \mathbf{V}\cdot \mathbf{\hat{n}} \mathrm{d}\ell = \int_S \mathbf{\nabla} \cdot \mathbf{V} \mathrm{d}A\)</span>,</p>
<p>whre the curve <span class="math notranslate nohighlight">\(C\)</span> is the boundary of the surface <span class="math notranslate nohighlight">\(S\)</span>, and <span class="math notranslate nohighlight">\(\mathbf{\hat{n}}\)</span> is a unit vector perpendicular to <span class="math notranslate nohighlight">\(C\)</span>.</p>
<p>Changing <span class="math notranslate nohighlight">\(\mathbf{V} \rightarrow u\mathbf{V}\)</span>, where <span class="math notranslate nohighlight">\(u\)</span> is a scalar function:</p>
<p><span class="math notranslate nohighlight">\(\int_C u\mathbf{V}\cdot \mathbf{\hat{n}} \mathrm{d}\ell = \int_S \mathbf{\nabla} \cdot (u\mathbf{V}) \mathrm{d}A\)</span>.</p>
<p>Consider the RHS and expand:</p>
<p><span class="math notranslate nohighlight">\(\int_S \mathbf{\nabla} \cdot (u\mathbf{V}) \mathrm{d}A = \int_S u\mathbf{\nabla} \cdot \mathbf{V} \mathrm{d}A + \int_S \mathbf{\nabla }u \cdot \mathbf{V} \mathrm{d}A\)</span>.</p>
<p>And rearranging:</p>
<p><span class="math notranslate nohighlight">\(\int_S \mathbf{\nabla}u \cdot \mathbf{V} \mathrm{d}A = \int_S \mathbf{\nabla} \cdot (u\mathbf{V}) \mathrm{d}A - \int_S u\mathbf{\nabla} \cdot \mathbf{V} \mathrm{d}A\)</span>.</p>
<p>By the divergence theorem as written above:</p>
<p><span class="math notranslate nohighlight">\(\int_S \mathbf{\nabla}u \cdot \mathbf{V} \mathrm{d}A = \int_C u\mathbf{V}\cdot \mathbf{\hat{n}} \mathrm{d}\ell - \int_S u\mathbf{\nabla} \cdot \mathbf{V} \mathrm{d}A\)</span>.</p>
<p>If we now choose <span class="math notranslate nohighlight">\(\mathbf{V} = \mathbf{\nabla}\phi\)</span> and <span class="math notranslate nohighlight">\(u = \delta \phi\)</span>, we have:</p>
<p><span class="math notranslate nohighlight">\(\int_S \mathbf{\nabla }\delta \phi \cdot\mathbf{\nabla}\phi \mathrm{d}A = \int_C \delta \phi \mathbf{\nabla} \phi\cdot\mathbf{\hat{n}} \mathrm{d}\ell - \int_S \delta \phi \mathbf{\nabla} \cdot \mathbf{\nabla} \phi \mathrm{d}A \)</span>,</p>
<p>an integration by parts formula in the necessary form.</p>
<p>Substituting the above into:</p>
<p><span class="math notranslate nohighlight">\(\delta \mathcal{E} = \int_0^1 \mathrm{d} x \int_0^1 \mathrm{d} y \left[ \nabla \phi \cdot \nabla \delta \phi - S \delta \phi\right]\)</span>,</p>
<p>we get:</p>
<p><span class="math notranslate nohighlight">\(\delta \mathcal{E} = \int_C \delta \phi \mathbf{\nabla} \phi\cdot \mathbf{\hat{n}} \mathrm{d}\ell + \int_0^1 \mathrm{d} x \int_0^1 \mathrm{d}y\delta \phi  [-\nabla^2 \phi - S]\)</span>,</p>
<p>where the line integral is over the boundary of the region of interest (<span class="math notranslate nohighlight">\(C\)</span>). Since we consider only variations that respect the boundary conditions, <span class="math notranslate nohighlight">\(\delta \phi\)</span> must vanish on <span class="math notranslate nohighlight">\(C\)</span>, so that the line integral does as well.</p>
<p>Therefore:</p>
<p><span class="math notranslate nohighlight">\(\delta \mathcal{E} = \int_0^1 \mathrm{d} x \int_0^1 \mathrm{d}y\delta \phi  [-\nabla^2 \phi - S]\)</span>,</p>
<p>and demanding that <span class="math notranslate nohighlight">\(\delta \mathcal{E} =0\)</span> for any <span class="math notranslate nohighlight">\(\delta \phi\)</span> implies that:</p>
<p><span class="math notranslate nohighlight">\(-\nabla^2 \phi - S = 0\)</span>, i.e. that <span class="math notranslate nohighlight">\(\mathcal{E}\)</span> is stationary when <span class="math notranslate nohighlight">\(\phi\)</span> is a solution to our differential equation.</p>
<p>Moreover, it can be shown that <span class="math notranslate nohighlight">\(\mathcal{E}\)</span> is not only stationary when <span class="math notranslate nohighlight">\(\phi\)</span> is a solution to the PDE, but that it is a minimum as well (left as an exercise!).</p>
<p>Let’s also derive a discrete approximation to the <span class="math notranslate nohighlight">\(\mathcal{E}\)</span> functional. We employ a two-point difference formula to approximate each first derivative in <span class="math notranslate nohighlight">\((\mathbf{\nabla}\phi)^2\)</span>, at the points halfway between the lattice points, and use the trapezoid rule for the integrals.</p>
<p>As a reminder, the trapezoid rule for integration in one dimension is given by:</p>
<p><span class="math notranslate nohighlight">\(\int_a^b \mathrm{d} x f(x) = \frac{h}{2} \left[ f(a) + f(b) + 2 \sum_{i=1}^{N-1} f(x_i)\right]\)</span>.</p>
<p>In two dimensions, it can be shown that the trapezoid rule has the form:</p>
<p>\begin{align}
\int_a^b \mathrm{d} x \int_c^d \mathrm{d} y f(x,y) &amp;= \frac{h^2}{4} [f(a,c) + f(b,c) + f(a,d) + f(b,d)\
&amp;+ 2 \sum_{i=1}^{N-1} f(x_i, c) + 2 \sum_{i=1}^{N-1} f(x_i, d)\
&amp;+ 2 \sum_{j=1}^{N-1} f(a, y_j) + 2 \sum_{i=1}^{N-1} f(b, y_j)\
&amp;+ 4 \sum_{i=1}^{N-1} \sum_{j=1}^{N-1} f(x_i, y_j)]
\end{align}</p>
<p>(see, e.g., <a class="reference external" href="https://math.stackexchange.com/questions/2891298/derivation-of-2d-trapezoid-rule">https://math.stackexchange.com/questions/2891298/derivation-of-2d-trapezoid-rule</a> for a derivation)</p>
<p>This leads to:</p>
<p><span class="math notranslate nohighlight">\(\mathcal{E} = \frac{1}{2} \sum_{i=1}^N \sum_{j=1}^N [(\phi_{ij} - \phi_{i-1j})^2 + (\phi_{ij} - \phi_{ij-1})^2 ] - h^2 \sum_{i=1}^{N-1} \sum_{j=1}^{N-1} S_{ij} \phi_{ij}\)</span>.</p>
<p>Note that setting:</p>
<p><span class="math notranslate nohighlight">\(\frac{ \partial \mathcal{E}}{\partial \phi_{ij}} = 0 \forall ij\)</span>,</p>
<p>leads to the difference equation derived in the previous section.</p>
<p>Let’s now discuss where the boundary conditions enter the set of the linear equations:</p>
<p><span class="math notranslate nohighlight">\(-\left[\frac{ \phi_{i+1j} + \phi_{i-1j} - 2 \phi_{ij}}{h^2} + \frac{ \phi_{ij+1} + \phi_{ij-1} - 2 \phi_{ij}}{h^2}\right] = S_{ij}\)</span>.</p>
<p>Unless the coordinate system is well adapted to the geometry of the surfaces on which the boundary conditions are imposed, the lattice points will only roughly describe the geometry. One can always improve the accuracy by using a non-uniform lattice spacing, and place more points in the regions near the surfaces, or by transforming to a coordinate system in which the boundary conditions are expressed more naturally.</p>
<p>In any event, the boundary conditions will then provide the values of the <span class="math notranslate nohighlight">\(\phi_{ij}\)</span> at some subset of lattice points.</p>
<p>At a point far away from the boundaries, the boundary conditions do not enter directly. However, consider the equation at a point <em>just next</em> to the boundary, say <span class="math notranslate nohighlight">\((i, N-1)\)</span>. Since <span class="math notranslate nohighlight">\(\phi_{iN}\)</span> is specified as a part of the boundary conditions, we can rewrite the equation as:</p>
<p><span class="math notranslate nohighlight">\(4 \phi_{iN-1} - \phi_{i+1N-1} - \phi_{i-1N-1} - \phi_{iN-2} = h^2 S_{ij} + \phi_{iN}\)</span>.</p>
<p>Therefore, <span class="math notranslate nohighlight">\(\phi_{iN}\)</span> enters <em>not</em> as an unknown, but rather as an inhomogeneous, <em>known</em> term.</p>
<p>These considerations show that the discrete approximation to the PDE is equivalent to a system of linear equations for the unknown values of <span class="math notranslate nohighlight">\(\phi\)</span> at the interior points.</p>
<p>In matrix notation:</p>
<p><span class="math notranslate nohighlight">\(\mathbf{M} \mathbf{\phi} = \mathbf{s}\)</span>,</p>
<p>where <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the matrix appearing in the linear system of equations, and the inhomogeneous term <span class="math notranslate nohighlight">\(\mathbf{s}\)</span> is proportional to <span class="math notranslate nohighlight">\(S\)</span> at the interior points, and linearly related to the boundary conditions on <span class="math notranslate nohighlight">\(\phi\)</span>.</p>
<p>In any sort of practical situation, there are a very large number of these equations, e.g. <span class="math notranslate nohighlight">\(N^2 = 2500\)</span> for, say, <span class="math notranslate nohighlight">\(N=50\)</span>, so the solution by direct matrix inversion can be impractical.</p>
<p>Fortunately, sincew the discrete approximation to the Laplacian involves only neighboring points, most of the elements of <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> vanish (since it is sparse), and there are efficient iterative techniques for solving the matrix equation.</p>
<p>We begin their discussion by considering an analogous, but simpler one-dimensional boundary value problem, and then return to the two-dimensional case.</p>
</section>
<section id="an-iterative-method-for-boundary-value-problems">
<h3><span class="section-number">10.2.3. </span>An Iterative Method for Boundary Value Problems<a class="headerlink" href="#an-iterative-method-for-boundary-value-problems" title="Link to this heading">#</a></h3>
<p>The one-dimensional boundary value problem analogous to the two-dimensional problem we have been discussing can be written as:</p>
<p><span class="math notranslate nohighlight">\( -\frac{ \mathrm{d}^2 \phi }{\mathrm{d} x^2} = S(x)\)</span>,</p>
<p>with <span class="math notranslate nohighlight">\(\phi(0)\)</span> and <span class="math notranslate nohighlight">\(\phi(1)\)</span> specified.</p>
<p>The related variational principle involves the quantity:</p>
<p><span class="math notranslate nohighlight">\(\mathcal{E} = \int_0^1 \mathrm{d} x \left[ \frac{1}{2} \left(\frac{\mathrm{d}\phi}{\mathrm{d}x}\right)^2 - S \phi \right]\)</span>.</p>
<p>This can be discretized on a uniform lattice with spacing <span class="math notranslate nohighlight">\(h=1/N\)</span> as:</p>
<p><span class="math notranslate nohighlight">\(\mathcal{E} = \frac{1}{2h} \sum_i^{N-1} (\phi_i - \phi_{i-1})^2 - h \sum_{i=1}^{N-1} S_i \phi_i\)</span>.</p>
<p>Considering variations with respect to <span class="math notranslate nohighlight">\(\phi_i\)</span> yields the difference equation:</p>
<p><span class="math notranslate nohighlight">\(2 \phi_i - \phi_{i+1} - \phi_{i-1} = h^2 S_i\)</span>,</p>
<p>which is nothing but the naive discretization of the differential equation.</p>
<p>We already discussed methods for solving the boundary value problem in one dimension in the previous chapter (using the forward/backward Numerov method), but we can also consider the equation together with the known values <span class="math notranslate nohighlight">\(\phi_0\)</span> and <span class="math notranslate nohighlight">\(\phi_N\)</span>, as a set of linear equations.</p>
<p>For a modest number of points, say <span class="math notranslate nohighlight">\(N \lesssim 100\)</span>, the system can be solved by direct matrix methods.</p>
<p>However, to illustrate the iterative methods appropriate for large sparse matrices of elliptic PDEs in two or more dimensions, let’s begin by solving for <span class="math notranslate nohighlight">\(\phi\)</span>:</p>
<p><span class="math notranslate nohighlight">\(\phi_i = \frac{1}{2} [ \phi_{i+1} + \phi_{i-1} + h^2 S_i]\)</span>.</p>
<p>This equation is not manifestly useful, since we don’t know the <span class="math notranslate nohighlight">\(\phi\)</span>’s on the RHS. However, it can be interpreted as giving as an “improved” value for <span class="math notranslate nohighlight">\(\phi_i\)</span>, based on the values of <span class="math notranslate nohighlight">\(\phi\)</span> at the neighboring points.</p>
<p>The strategy, known as Gauss-Seidel iteration, is then to guess some initial solution, and then to “sweep” systematically through the lattice (e.g. from left to right), successively replacing <span class="math notranslate nohighlight">\(\phi\)</span> at each point by an improved value.</p>
<p>Note that the most “current” values of the <span class="math notranslate nohighlight">\(\phi_{i\pm 1}\)</span> are to be used in the RHS of the equation. By repeating this sweep many times, an initial guess for <span class="math notranslate nohighlight">\(\phi\)</span> can be “relaxed” to the correct solution.</p>
<p>To investigate the convergence of this procedure, we generalize the equation, so that at each step of the relaxation, <span class="math notranslate nohighlight">\(\phi_i\)</span> is replaced by a linear mixture of its old value and the new “improved” one, given by:</p>
<p><span class="math notranslate nohighlight">\(\phi_i \rightarrow \phi_i' = (1-\omega) \phi_i + \frac{\omega}{2} [\phi_{i+1} + \phi_{i-1} + h^2 S_i]\)</span>.</p>
<p>Here, <span class="math notranslate nohighlight">\(\omega\)</span> is a parameter that can be adjusted to control the rate of relaxation.</p>
<p>To see that the above procedure leads to an “improvement” in the solution, we calculate the change in the energy functional (in one dimension), remembering that all the <span class="math notranslate nohighlight">\(\phi\)</span>’s except <span class="math notranslate nohighlight">\(\phi_i\)</span> are to be held fixed. After some algebra, one finds:</p>
<p><span class="math notranslate nohighlight">\(E'-E = -\frac{ \omega(2-\omega)}{2h} \left[ \frac{1}{2} (\phi_{i+1} + \phi_{i-1} + h^2 S_i) - \phi_i \right]^2 \leq 0\)</span>,</p>
<p>so that, as long as <span class="math notranslate nohighlight">\(0 &lt; \omega &lt; 2\)</span>, the energy never increases, and should thus converge to the required minimum value as the sweeps proceed.</p>
</section>
<section id="example-10-1-the-relaxation-method-for-partial-differential-equations-in-one-dimension">
<h3><span class="section-number">10.2.4. </span>Example 10.1: The relaxation method for partial differential equations in one dimension.<a class="headerlink" href="#example-10-1-the-relaxation-method-for-partial-differential-equations-in-one-dimension" title="Link to this heading">#</a></h3>
<p>(a) Use the relaxation method in one dimension to solve the boundary value problem defined by the differential equation:</p>
<p><span class="math notranslate nohighlight">\(-\frac{ \mathrm{d}^2 \phi }{\mathrm{d} x^2} = S(x)\)</span>,</p>
<p>with source term <span class="math notranslate nohighlight">\(S(x) = 12 x^2\)</span> and boundary conditions <span class="math notranslate nohighlight">\(\phi(0) = \phi(1) = 0\)</span>. Start with <span class="math notranslate nohighlight">\(\phi_i=0\)</span> as your initial guess. Use <span class="math notranslate nohighlight">\(N=40\)</span> lattice steps and perform a few hundred iterations (e.g. 1000) to reach your solution. Perform all calculations for the values of the relaxation parameter <span class="math notranslate nohighlight">\(\omega = 0.5, 1.0, 1.5\)</span>.</p>
<p>The relaxation method: Discretize the one-dimensional space and use the discretized “solved” iterative form:</p>
<p><span class="math notranslate nohighlight">\(\phi_i \rightarrow \phi'_i = (1-\omega)\phi_i + \frac{\omega}{2} [ \phi_{i+1} + \phi_{i-1} + h^2 S_i]\)</span>,</p>
<p>where <span class="math notranslate nohighlight">\(\phi_i'\)</span> is the updated value of <span class="math notranslate nohighlight">\(\phi_i\)</span> at lattice site <span class="math notranslate nohighlight">\(i\)</span>, <span class="math notranslate nohighlight">\(h\)</span> is the lattice spacing, and <span class="math notranslate nohighlight">\(\omega\)</span> is a “relaxation” parameter.</p>
<p>Compare to the exact solution: <span class="math notranslate nohighlight">\(\phi(x) = x(1-x^3)\)</span>.</p>
<p>(b) Write a function that calculates the energy functional, defined by:</p>
<p><span class="math notranslate nohighlight">\(\mathcal{E} = \int_0^1 \mathrm{d}x \left[ \frac{1}{2} \left( \frac{\mathrm{d}\phi }{\mathrm{d} x} \right)^2 - S \phi \right]\)</span>.</p>
<p>Use the discretized form:</p>
<p><span class="math notranslate nohighlight">\(\mathcal{E}= \frac{1}{2h} \sum_{i=1}^N (\phi_i - \phi_{i-1})^2 - h \sum_{i=1}^{N-1} S_i \phi_i\)</span>.</p>
<p>Calculate the value of the energy at the end of each iteration and plot the energy as a function of iteration.</p>
<p>Compare to the exact solution energy given by: <span class="math notranslate nohighlight">\(\mathcal{E} = -9/14 \simeq -0.64286\)</span>.</p>
<p>Despite the rather poor initial guess for <span class="math notranslate nohighlight">\(\phi\)</span> in Example 10.1, the iterations converge and the converged energy is independent of the relaxation parameter, <span class="math notranslate nohighlight">\(\omega\)</span>. The rate of convergence clearly depends on <span class="math notranslate nohighlight">\(\omega\)</span>. A general analysis shows that the best choice for the relaxation parameter depends upon the lattice size and on the geometry of the problem, and it is found to be usually <span class="math notranslate nohighlight">\(\omega &gt; 1\)</span>. The optimal value can be determined empirically by examining the convergence of the solution for only a few iterations, before choosing a value to be used for many iterations.</p>
</section>
<section id="the-relaxation-method-in-higher-dimensions">
<h3><span class="section-number">10.2.5. </span>The Relaxation Method in Higher Dimensions<a class="headerlink" href="#the-relaxation-method-in-higher-dimensions" title="Link to this heading">#</a></h3>
<p>The generalization of the relaxation method to two-dimensional problems is straightforward.</p>
<p>For the differential equation:</p>
<p><span class="math notranslate nohighlight">\(-\left[ \frac{\partial^2}{\partial x^2} + \frac{\partial^2}{\partial y^2}\right] \phi = S(x,y)\)</span>,</p>
<p>we get, for the updated value of the field at a point <span class="math notranslate nohighlight">\((x_i, y_j)\)</span>:</p>
<p><span class="math notranslate nohighlight">\(\phi_{ij} \rightarrow \phi_{ij}' = (1-\omega) \phi_{ij} + \frac{\omega}{4} [\phi_{i+1j} + \phi_{i-1j} + \phi_{ij+1} + \phi_{ij-1} + h^2 S_{ij}]\)</span>.</p>
<p>This algorithm can be applied successively to each point on the lattice, say sweeping the rows in order from top to bottom and each row from left to right. One can again show that the energy functional,</p>
<p><span class="math notranslate nohighlight">\(\mathcal{E} = \frac{1}{2} \sum_{i=1}^N \sum_{j=1}^N [(\phi_{ij} - \phi_{i-1j})^2 + (\phi_{ij} - \phi_{ij-1})^2 ] - h^2 \sum_{i=1}^{N-1} \sum_{j=1}^{N-1} S_{ij} \phi_{ij}\)</span>,</p>
<p>always decreases, and there will be convergence to the required solution.</p>
<p>Several considerations can serve to enhance the convergence in practice:</p>
<ol class="arabic simple">
<li><p>Starting from a good guess at the solution, e.g. perhaps one with similar, but simpler, boundary conditions, will reduce the number of iterations required.</p></li>
<li><p>An optimal value of the relaxation parameter should be used, either estimated analytically or determined empirically (as described above).</p></li>
<li><p>It may sometimes be more efficient to concentrate the relaxation process, for several iterations, in some sub-area of the lattice, where the trial solution is known to be particularly poor, thus not wasting effort on already-relaxed parts of the solution.</p></li>
<li><p>One can always do a calculation on a relatively coarse lattice that relaxes with a small amount of numerical work, and then interpolate the solution found onto a finer lattice, to be used as the starting guess for further iterations.</p></li>
</ol>
</section>
</section>
<section id="parabolic-partial-differential-equations">
<h2><span class="section-number">10.3. </span>Parabolic Partial Differential Equations<a class="headerlink" href="#parabolic-partial-differential-equations" title="Link to this heading">#</a></h2>
<p>Typical parabolic PDEs one encounters in physical situations are the diffusion equation:</p>
<p><span class="math notranslate nohighlight">\(\frac{\partial \phi}{\partial t} = \mathbf{\nabla} \cdot ( D \mathbf{\nabla} \phi ) + S\)</span>,</p>
<p>where <span class="math notranslate nohighlight">\(D\)</span> is the diffusion constant (possibly space-dependent) and <span class="math notranslate nohighlight">\(S\)</span> is a source function.</p>
<p>Another example is the Schrödinger equation:</p>
<p><span class="math notranslate nohighlight">\(i\frac{\partial \phi}{\partial t} = -\frac{ \hbar^2 } { 2 m} \nabla^2 \phi + V\phi\)</span>.</p>
<p>In contrast to the boundary value problems, these are generally of the initial value type: we are given the field <span class="math notranslate nohighlight">\(\phi\)</span> at an initial time, and seek to find it at a later time. The evolution is subject to certain spatial boundary conditions, e.g. the Schrödinger wave function vanishes at very large distances, or the temperature or heat flux is specified on some surfaces.</p>
<p>Methods by which such problems are solved on a computer are straightforward, although a few subtleties are involved.</p>
<section id="naive-discretization-and-instabilities">
<h3><span class="section-number">10.3.1. </span>Naive Discretization and Instabilities<a class="headerlink" href="#naive-discretization-and-instabilities" title="Link to this heading">#</a></h3>
<p>We begin by treating diffusion in one dimension, with a uniform diffusion constant <span class="math notranslate nohighlight">\(D=1\)</span>.</p>
<p>We take <span class="math notranslate nohighlight">\(x \in [0,1]\)</span> and assume Dirichlet boundary conditions that specify the value of the field at the end points of the interval.</p>
<p>We will focus on the rescaled equation:</p>
<p><span class="math notranslate nohighlight">\(\frac{\partial \phi}{\partial t} =  \frac{\partial^2 \phi}{\partial x^2} + S(x,t)\)</span>.</p>
<p>As before, we will approximate the spatial derivatives by finite differences on a uniform lattice of <span class="math notranslate nohighlight">\(N+1\)</span> points with spacing <span class="math notranslate nohighlight">\(h=1/N\)</span>. The time derivative will be approximated by the simplest first-order difference formula, assuming a time step <span class="math notranslate nohighlight">\(\Delta t\)</span>.</p>
<p>We will use a <em>superscript</em> <span class="math notranslate nohighlight">\(n\)</span> to label the time step:</p>
<p><span class="math notranslate nohighlight">\(\phi^n \equiv \phi(t_n)\)</span>, with <span class="math notranslate nohighlight">\(t_n = n \Delta t\)</span>.</p>
<p>As our first approximation to the equation, we approximate the second derivative on the RHS as follows:</p>
<p><span class="math notranslate nohighlight">\(\frac{\partial^2 \phi}{\partial x^2} \equiv -\hat{H}\phi \approx \frac{\phi^n_{i+1} + \phi^n_{i-1} - 2 \phi^n_i }{h^2}\)</span>,</p>
<p>where we have also defined an operator which corresponds to minus the second spatial derivative, with the discretized form:</p>
<p><span class="math notranslate nohighlight">\(\hat{H} \phi^n_i = - \frac{\phi^n_{i+1} + \phi^n_{i-1} - 2 \phi^n_i }{h^2}\)</span>.</p>
<p>An “explicit” discretization, or differencing scheme, of the differential equation is then given by:</p>
<p><span class="math notranslate nohighlight">\(\frac{ \phi_i^{n+1} - \phi_i^n }{\Delta t} = \frac{\phi^n_{i+1} + \phi^n_{i-1} - 2 \phi^n_i }{h^2} + S_i^n\)</span>.</p>
<p>If we then solve the differential equation for <span class="math notranslate nohighlight">\(\phi\)</span> at the next time step, we obtain:</p>
<p><span class="math notranslate nohighlight">\(\phi^{n+1} = (1-\hat{H} \Delta t) \phi^n + S^n \Delta t\)</span>,</p>
<p>where we have suppressed the index <span class="math notranslate nohighlight">\(i\)</span>, essentially turning the above equation to a matrix equation.</p>
</section>
<section id="example-10-2-parabolic-pdes-a-first-example">
<h3><span class="section-number">10.3.2. </span>Example 10.2: Parabolic PDEs: a first example<a class="headerlink" href="#example-10-2-parabolic-pdes-a-first-example" title="Link to this heading">#</a></h3>
<p>Solve the differential equation (i.e. find <span class="math notranslate nohighlight">\(\phi\)</span> for later times):</p>
<p><span class="math notranslate nohighlight">\(\frac{\partial \phi}{\partial t} = \frac{ \partial^2 \phi}{\partial x^2} + S(x,t)\)</span>,</p>
<p>for <span class="math notranslate nohighlight">\(S=0\)</span> and <span class="math notranslate nohighlight">\(\phi(0,t) = \phi(1,t) = 0\)</span>, satisfied by the initial condition of a Gaussian centered about <span class="math notranslate nohighlight">\(x=1/2\)</span>:</p>
<p><span class="math notranslate nohighlight">\(\phi(x,t=0) = e^{-20(x-1/2)^2} - e^{-20(x-3/2)^2} - e^{-20(x+1/2)^2}\)</span>,</p>
<p>where the latter two “image” Gaussians approximately ensure the boundary conditions at <span class="math notranslate nohighlight">\(x=1\)</span> and <span class="math notranslate nohighlight">\(x=0\)</span>, respectively.</p>
<p>Use the naive discretization formula:</p>
<p><span class="math notranslate nohighlight">\(\phi^{n+1} = (1 - \hat{H} \Delta t) \phi^n + S^n \Delta t\)</span>,</p>
<p>where <span class="math notranslate nohighlight">\((H\phi)_i\equiv -\frac{1}{h^2} ( \phi_i + \phi_{i-1} - 2 \phi_i)\)</span>.</p>
<p>Integrate up to <span class="math notranslate nohighlight">\(t_\mathrm{max} = 0.045\)</span> with a time steps <span class="math notranslate nohighlight">\(\Delta t = 0.00075\)</span> and <span class="math notranslate nohighlight">\(\Delta t = 0.0080\)</span>, over a lattice with <span class="math notranslate nohighlight">\(N=25\)</span>.</p>
<p>Compare to the analytical solution:</p>
<p><span class="math notranslate nohighlight">\(\phi(x,t) = \tau^{-1/2} \left[ e^{-20(x-1/2)^2/\tau} - e^{-20(x-3/2)^2/\tau} - e^{-20(x+1/2)^2/\tau} \right]\)</span>, where <span class="math notranslate nohighlight">\(\tau = 1 + 80t\)</span>.</p>
<p>Both time steps chosen are quite small compared to the natural time scale of the solution, <span class="math notranslate nohighlight">\(t\approx 0.01\)</span>. Furthermore, as we increase the time step, we see that things go very wrong: an unphysical instability develops in the numerical solution, which quickly acquires violent oscillations from one lattice point to another.</p>
<p>Let’s try to understand what is happening here. Consider the differential equation with <span class="math notranslate nohighlight">\(S=0\)</span>, as we are trying to solve in the above example:</p>
<p><span class="math notranslate nohighlight">\(\frac{\partial \phi}{\partial t} =  \frac{\partial^2 \phi}{\partial x^2}\)</span>.</p>
<p>The RHS can be replaced by the operator <span class="math notranslate nohighlight">\(-\hat{H}\)</span>, to obtain:</p>
<p><span class="math notranslate nohighlight">\(\frac{\partial \phi(x,t)}{\partial t} = -\hat{H} \phi(x,t)\)</span>.</p>
<p>This can be formally solved to give:</p>
<p><span class="math notranslate nohighlight">\(\phi(x,t) = e^{-t\hat{H}} \phi(x,0)\)</span>.</p>
<p>If we now discretize time: <span class="math notranslate nohighlight">\(t_n = n \Delta t\)</span>, <span class="math notranslate nohighlight">\(\phi(t_n,x) = \phi^n\)</span>, as before, we get:</p>
<p><span class="math notranslate nohighlight">\(\phi^n = e^{-n \Delta t \hat{H}} \phi^0\)</span>.</p>
<p>Now let the set of states <span class="math notranslate nohighlight">\(\psi_\lambda\)</span> be the <em>eigenfunctions</em> of the operator <span class="math notranslate nohighlight">\(\hat{H}\)</span> with eigenvalues <span class="math notranslate nohighlight">\(\epsilon_\lambda\)</span>.</p>
<p>Since <span class="math notranslate nohighlight">\(\hat{H}\)</span> is Hermitian, the eigenvalues <span class="math notranslate nohighlight">\(\epsilon_\lambda\)</span> are real and the eigenvectors can be chosen to be orthonormal.</p>
<p>What this implies is that we can expand the solution at any time in terms of this basis:</p>
<p><span class="math notranslate nohighlight">\(\phi^n = \sum_\lambda \phi^n_\lambda \psi_\lambda\)</span>,</p>
<p>where <span class="math notranslate nohighlight">\(\phi^n_\lambda\)</span> are effectively the coefficients of the expansion.</p>
<p>We also expand the initial condition in terms of the eigenvectors:</p>
<p><span class="math notranslate nohighlight">\(\phi^0 = \sum_{\lambda} \phi^0_\lambda \psi_\lambda\)</span>,</p>
<p>then, substituting into the formal discretized solution, <span class="math notranslate nohighlight">\(\phi^n = e^{-n \Delta t \hat{H}} \phi^0\)</span>, we obtain:</p>
<p><span class="math notranslate nohighlight">\(\sum_\lambda \phi^n_\lambda \psi_\lambda = e^{-n \hat{H} \Delta t} \sum_{\lambda} \phi_\lambda^0 \psi_\lambda\)</span>,</p>
<p>giving us the evolution of each component of the solution:</p>
<p><span class="math notranslate nohighlight">\(\phi_\lambda^n =  e^{-n \hat{H} \Delta t} \phi^0_\lambda\)</span>.</p>
<p>This corresponds to the correct behavior of the diffusion equation: short-wavelenght components (i.e. large eigenvalues <span class="math notranslate nohighlight">\(\epsilon_\lambda\)</span>, disappear more rapidly as the solution “smooths out”.</p>
<p>However, the naive discretization (i.e. the “explicit” scheme):</p>
<p><span class="math notranslate nohighlight">\(\phi^{n+1} = (1 - \hat{H} \Delta t) \phi^n\)</span>,</p>
<p>would result in:</p>
<p><span class="math notranslate nohighlight">\(\phi^n = (1 - \hat{H} \Delta t)^n \phi_0\)</span>,</p>
<p>or:</p>
<p><span class="math notranslate nohighlight">\(\phi^n_\lambda = (1- \epsilon_\lambda \Delta t)^n \phi^0\)</span>.</p>
<p>Recall one of the definitions of the exponential function:</p>
<p><span class="math notranslate nohighlight">\(e^{\alpha t} = \lim_{n\rightarrow \infty} (1 + \alpha \Delta t)^n\)</span>, with <span class="math notranslate nohighlight">\(\Delta t = t/n\)</span>.</p>
<p>So the naive discretization in the limit <span class="math notranslate nohighlight">\(\Delta t \rightarrow 0\)</span> would yield the correct evolution:</p>
<p><span class="math notranslate nohighlight">\(\phi^n_\lambda = e^{-n \epsilon_\lambda \Delta t} \phi^0_\lambda\)</span>.</p>
<p>Therefore, as long as <span class="math notranslate nohighlight">\(\Delta t\)</span> is chosen to be small, <span class="math notranslate nohighlight">\((1-\epsilon_\lambda \Delta t)^n\)</span> approximates the exponential, and the short-wavelength (large <span class="math notranslate nohighlight">\(\epsilon_\lambda\)</span>) components dampen with time.</p>
<p>However, if <span class="math notranslate nohighlight">\(\Delta t\)</span> is too large, one or more of the quantities <span class="math notranslate nohighlight">\(1 - \epsilon_\lambda \Delta t\)</span> has an absolute value greater than unity. The corresponding components, even if present only due to very small numerical round-off errors, are then amplified with each time step, and soon grow to dominate.</p>
<p>To quantify the limit on <span class="math notranslate nohighlight">\(\Delta t\)</span>, we have some guidance in that the eigenvalues of <span class="math notranslate nohighlight">\(\hat{H}\)</span> are known analytically in this simple model problem.</p>
<p>We have: <span class="math notranslate nohighlight">\(\hat{H} = - \frac{ \partial^2 }{ \partial x^2}\)</span>. The eigenvalue equation is simply then:</p>
<p><span class="math notranslate nohighlight">\(\hat{H} \psi_\lambda = \epsilon_\lambda \psi_\lambda\)</span></p>
<p><span class="math notranslate nohighlight">\(\Rightarrow \frac{ \partial^2 \psi_\lambda }{ \partial x^2} = - \epsilon_\lambda \psi_\lambda\)</span>,</p>
<p>with <span class="math notranslate nohighlight">\(\psi_\lambda(0) = \psi_\lambda(1) = 0\)</span>.</p>
<p>The eigenfunctions are then:</p>
<p><span class="math notranslate nohighlight">\(\psi_\lambda = A \sin \sqrt{\epsilon_\lambda} x\)</span>, with eigenvalues <span class="math notranslate nohighlight">\(\sqrt{\epsilon_\lambda} = \lambda \pi\)</span>, with <span class="math notranslate nohighlight">\(\lambda = 1,2,...\)</span>.</p>
<p>On a lattice with <span class="math notranslate nohighlight">\(x_i = ih\)</span>, the discretized solutions are then:</p>
<p><span class="math notranslate nohighlight">\((\psi_\lambda)_i = A \sin \lambda \pi i h\)</span>,</p>
<p>and since <span class="math notranslate nohighlight">\(h = 1/N\)</span>:</p>
<p><span class="math notranslate nohighlight">\((\psi_\lambda)_i = A \sin \frac{\lambda \pi i}{N}\)</span>.</p>
<p>The eigenvalues have to change when we move to the lattice. To find them, consider the action of the discretized form of <span class="math notranslate nohighlight">\(\hat{H}\)</span> on the discretized eigenfunctions:</p>
<p><span class="math notranslate nohighlight">\((\hat{H}\psi_\lambda)_i = -\frac{1}{h^2} \left[ (\psi_\lambda)_{i+1} + (\psi_\lambda)_{i-1} - 2 (\psi_\lambda)_{i} \right]\)</span>.</p>
<p>or:</p>
<p><span class="math notranslate nohighlight">\((\hat{H}\psi_\lambda)_i = -\frac{1}{h^2} \left[ \sin \frac{ \lambda \pi (i+1) } {N} + \sin \frac{ \lambda \pi (i-1) } {N}  - 2 \sin \frac{ \lambda \pi i} {N} \right]\)</span>.</p>
<p>Using the trigonometric identities <span class="math notranslate nohighlight">\(\sin(A+B) = \sin A \cos B + \sin B \cos A\)</span> and <span class="math notranslate nohighlight">\(1-\cos \frac{ \lambda \pi } {N} = 2 \sin^2 \frac{ \lambda \pi } { 2N }\)</span>, it easy to verify that the eigenvalues after discretization are:</p>
<p><span class="math notranslate nohighlight">\(\epsilon_\lambda = \frac{4}{h^2} \sin^2 \frac{ \lambda \pi }{2 N}\)</span>.</p>
<p>The largest eigenvalue corresponds to: <span class="math notranslate nohighlight">\(\lambda = N-1\)</span>, i.e.:</p>
<p><span class="math notranslate nohighlight">\(\epsilon_\lambda = 4/h^2 \left[ \sin\left(\frac{N\pi}{2N}\right) \cos\left(\frac{\pi}{2N}\right) - \cos\left(\frac{N\pi}{2N}\right) \sin\left(\frac{\pi}{2N}\right) \right]= 4/h^2 \cos\left(\pi/2N \right)\)</span>,</p>
<p>and to an eigenvector that changes sign from one lattice point to the next:</p>
<p><span class="math notranslate nohighlight">\((\psi_{N-1})_i = A \sin\left(\frac{(N-1) \pi i}{N}\right) = A\left[ \sin(\pi i) \cos\left(\frac{\pi i}{N}\right) - \cos(\pi i) \sin\left(\frac{\pi i}{N}\right)\right] \propto \cos \pi i\)</span>.</p>
<p>Requiring that <span class="math notranslate nohighlight">\(| 1 - \epsilon_\lambda \Delta t | &lt; 1\)</span>, then yields: <span class="math notranslate nohighlight">\(\Delta t \lesssim h^2/2\)</span>, which in the case of our example corresponds to <span class="math notranslate nohighlight">\(\Delta t \lesssim 0.0008\)</span>.</p>
<p>The question of stability is quite distinct from that of accuracy, as the limit imposed on the time step is set up by the spatial step used and not by the characteristic time scale of the solution, which is much larger.</p>
<p>The explicit scheme which we have discussed is unsatisfactory, as the instability forces us to use a much smaller time step than is required to describe the evolution adequately. Indeed, the situation gets even worse if we try to use a finer spatial lattice to obtain a more accurate solution.</p>
<p>Although the restriction on <span class="math notranslate nohighlight">\(\Delta t\)</span> that we have derived is rigorous only for the simple case we have considered, it does provide a useful guide for more complicated situations, as the eigenvector of <span class="math notranslate nohighlight">\(\hat{H}\)</span> with the largest eigenvalue will always oscillate from one lattice point to the next. Its eigenvalue is therefore quite insensitive to the global features of the problem.</p>
</section>
<section id="implicit-schemes">
<h3><span class="section-number">10.3.3. </span>Implicit Schemes<a class="headerlink" href="#implicit-schemes" title="Link to this heading">#</a></h3>
<p>One way around the instability of the explicit algorithm discussed above, is to retain the general form:</p>
<p><span class="math notranslate nohighlight">\(\frac{ \phi_i^{n+1} - \phi_i^n }{\Delta t} = \frac{\phi^n_{i+1} + \phi^n_{i-1} - 2 \phi^n_i }{h^2} + S_i^n\)</span>,</p>
<p>but to replace the second space derivative by that of the solution, <em>at the new time</em>, i.e.:</p>
<p><span class="math notranslate nohighlight">\(\frac{ \phi_i^{n+1} - \phi_i^n }{\Delta t} = \frac{\phi^{n+1}_{i+1} + \phi^{n+1}_{i-1} - 2 \phi^{n+1}_i }{h^2} + S_i^n\)</span>.</p>
<p>This defines an <em>implicit</em> scheme, since the unknown, <span class="math notranslate nohighlight">\(\phi^{n+1}\)</span> appears on both sides of the equation.</p>
<p>In terms of the operator <span class="math notranslate nohighlight">\((\hat{H}\phi^{n+1})_i = -\frac{\phi^{n+1}_{i+1} + \phi^{n+1}_{i-1} - 2 \phi^{n+1}_i}{h^2}\)</span>, the above implicit equation can be written as:</p>
<p><span class="math notranslate nohighlight">\(\frac{ \phi_i^{n+1} - \phi_i^n }{\Delta t} = -\hat{H}\phi^{n+1}_i + S_i^n\)</span>.</p>
<p>Solving for <span class="math notranslate nohighlight">\(\phi^{n+1}\)</span>, we get:</p>
<p><span class="math notranslate nohighlight">\(\phi^{n+1} = \frac{1}{1 + \hat{H} \Delta t} \left[ \phi^n + S^n \Delta t \right]\)</span>.</p>
<p>This scheme is equivalent to the explicit scheme to lowest order in <span class="math notranslate nohighlight">\(\Delta t\)</span> (as seen by expanding the denominator). However, it is much better in that larger time steps can be used, as the operator <span class="math notranslate nohighlight">\((1 + \hat{H} \Delta t)^{-1}\)</span> has eigenvalues <span class="math notranslate nohighlight">\((1+\epsilon_\lambda \Delta t)^{-1}\)</span>, all of whose moduli are less than 1 for any value of <span class="math notranslate nohighlight">\(\Delta t\)</span>. Although this decrease is inaccurate (i.e. not exponential as expected by the “formal” solution of the diffusion equation), for the most rapidly oscillating components, such components should not be large in the initial conditions, if the spatial discretization is accurate.</p>
<p>In any event, there’s no amplification of the large-eigenvalue components, which caused the instability found in the explicit scheme. For the slowly-varying components of the solution, corresponding to small eigenvalues, the evolution closely approximates the exponential behavior at each step.</p>
<p>A potential drawback is that it requires the solution of a set of linear equations (albeit tri-diagonal) at each time step to find <span class="math notranslate nohighlight">\(\phi^{n+1}\)</span>. This is equivalent to the application of the inverse of the matrix <span class="math notranslate nohighlight">\((1+\hat{H} \Delta t)\)</span> to the vector appearing in the brackets. Since the inverse itself is time-independent, it might be found only once at the beginning of the calculation and then used for all times, but application still requires <span class="math notranslate nohighlight">\(N^2\)</span> operations if done directly.</p>
<p>Fortunately, there exists an algorithm that provides a very efficient solution (<span class="math notranslate nohighlight">\(\mathcal{O}(N)\)</span> operations) of a tri-diagonal system of equations, known as “Gaussian elimination and back-substitution”.</p>
<p>The algorithm proceeds as follows: let’s consider trying to solve the tri-diagonal linear system of equations:</p>
<p><span class="math notranslate nohighlight">\(\mathbf{A} \mathbf{\phi} = \mathbf{b}\)</span> for the unknowns <span class="math notranslate nohighlight">\(\phi_i\)</span>:</p>
<p><span class="math notranslate nohighlight">\(A_i^- \phi_{i-1}^{n+1} + A^0_i \phi_i^{n+1} + A^+_i \phi_{i+1}^{n+1} = b_i\)</span>.</p>
<p>Here, the <span class="math notranslate nohighlight">\(A^{\pm,0}\)</span> are the only non-vanishing elements of <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> and the <span class="math notranslate nohighlight">\(b_i\)</span> are the known quantities. This is exactly the form of the problem posed by the evaluation of our problem:</p>
<p><span class="math notranslate nohighlight">\(\frac{ \phi_i^{n+1} - \phi_i^n }{\Delta t} = \frac{\phi^{n+1}_{i+1} + \phi^{n+1}_{i-1} - 2 \phi^{n+1}_i }{h^2} + S_i^n\)</span>.</p>
<p>rearranging:</p>
<p><span class="math notranslate nohighlight">\(\phi_i^{n+1} - \frac{\Delta t}{h^2} \left[\phi^{n+1}_{i+1} + \phi^{n+1}_{i-1} - 2 \phi^{n+1}_i\right] =  \phi_i^n + S_i^n\)</span>,</p>
<p>to get:</p>
<p><span class="math notranslate nohighlight">\( - \frac{\Delta t}{h^2} \phi^{n+1}_{i-1} + \left( 1 - 2\frac{\Delta t} {h^2}\right) \phi^{n+1}_i  - \frac{\Delta t}{h^2} \phi^{n+1}_{i+1} =  \phi_i^n + S_i^n\)</span>,</p>
<p>which corresponds to:</p>
<p><span class="math notranslate nohighlight">\(b_i = \phi_i^n + S_i^n \Delta t\)</span>,</p>
<p><span class="math notranslate nohighlight">\(A_i^0 = 1 + 2\frac{\Delta t} {h^2}\)</span>,</p>
<p><span class="math notranslate nohighlight">\(A_i^\pm = - \frac{\Delta t} {h^2}\)</span>.</p>
<p>To solve this system of equations, we assume that the solution satisfies a one-term <em>forward</em> recursion relation of the form:</p>
<p><span class="math notranslate nohighlight">\(\phi^{n+1}_{i+1} = \alpha_i \phi^{n+1}_i + \beta_i\)</span>,</p>
<p>where the coefficients <span class="math notranslate nohighlight">\(\alpha_i\)</span> and <span class="math notranslate nohighlight">\(\beta_i\)</span> are to be determined.</p>
<p>Substituting the above relation into the linear system of equations:</p>
<p><span class="math notranslate nohighlight">\(A^-_i \phi_{i-1}^{n+1} + A_i^0 \phi_i^{n+1} + A_i^+ (\alpha_i \phi^{n+1}_i + \beta_i) = b_i\)</span>,</p>
<p>and solving for <span class="math notranslate nohighlight">\(\phi_i^{n+1}\)</span>, we get:</p>
<p><span class="math notranslate nohighlight">\(\phi^{n+1}_i = \gamma_i A_i^- \phi^{n+1}_{i-1} + \gamma_i (A^+_i \beta_i - b_i)\)</span>,</p>
<p>with <span class="math notranslate nohighlight">\(\gamma_i = -\frac{ 1 }{A_i^0 + A_i^+ \alpha_i}\)</span>.</p>
<p>comparing the above with: <span class="math notranslate nohighlight">\(\phi^{n+1}_{i} = \alpha_{i-1} \phi^{n+1}_{i-1} + \beta_{i-1}\)</span>, i.e. the hypothesis with <span class="math notranslate nohighlight">\(i\rightarrow i-1\)</span>, we can identify the following recursion relations for the <span class="math notranslate nohighlight">\(\alpha\)</span>’s and <span class="math notranslate nohighlight">\(\beta\)</span>’s:</p>
<p><span class="math notranslate nohighlight">\(\alpha_{i-1} = \gamma_i A^-_i\)</span>,</p>
<p><span class="math notranslate nohighlight">\(\beta_{i-1} = \gamma_i (A_i^+ \beta_i - b_i)\)</span>.</p>
<p>Note that these are <em>backward</em> recursion relations.</p>
<p>The strategy to solve the problem then proceeds as follows:</p>
<ol class="arabic simple">
<li><p>We use the <span class="math notranslate nohighlight">\(\alpha_{i-1}\)</span>, <span class="math notranslate nohighlight">\(\beta_{i-1}\)</span> and <span class="math notranslate nohighlight">\(\gamma_i\)</span> relations to sweep the lattice <em>backwards</em> to determine the <span class="math notranslate nohighlight">\(\alpha_i\)</span> and <span class="math notranslate nohighlight">\(\beta_i\)</span>, running from <span class="math notranslate nohighlight">\(N-2\)</span> down to 0. The starting values to be used are: <span class="math notranslate nohighlight">\(\alpha_{N-1} = 0\)</span> and <span class="math notranslate nohighlight">\(\beta_{N-1} = \phi_N^n\)</span>, which will guarantee the correct value of <span class="math notranslate nohighlight">\(\phi\)</span> at the last lattice point</p></li>
<li><p>Having determined these coefficients, we can then use the recursion relation: <span class="math notranslate nohighlight">\(\phi^{n+1}_{i+1} = \alpha_i \phi^{n+1}_i + \beta_i\)</span> in a <em>forward</em> sweep from <span class="math notranslate nohighlight">\(i=0\)</span> to <span class="math notranslate nohighlight">\(i=N-1\)</span> to determine the solution, with the starting value of <span class="math notranslate nohighlight">\(\phi_0^{n+1}\)</span> known from the boundary conditions.</p></li>
</ol>
<p>We have then determined the solution in only two sweeps of he lattice, involving <span class="math notranslate nohighlight">\(\mathcal{O}(N)\)</span> arithmetic operations. The increase in numerical effort per time step is about a factor of two.</p>
<p><em>Note that</em>: the <span class="math notranslate nohighlight">\(\alpha_i\)</span> and <span class="math notranslate nohighlight">\(\gamma_i\)</span> are independent of <span class="math notranslate nohighlight">\(\mathbf{b}\)</span>, so that it is more efficient to compute these coefficients only once and store them at the beginning of the calculation. Only the <span class="math notranslate nohighlight">\(\beta_i\)</span> are then needed to be computed for each time step.</p>
</section>
<section id="example-10-3-application-of-the-implicit-scheme-for-parabolic-pdes">
<h3><span class="section-number">10.3.4. </span>Example 10.3: Application of the Implicit Scheme for Parabolic PDEs<a class="headerlink" href="#example-10-3-application-of-the-implicit-scheme-for-parabolic-pdes" title="Link to this heading">#</a></h3>
<p>Use the implicit scheme to solve the problem of Example 10.2. Use a lattice with <span class="math notranslate nohighlight">\(N=25\)</span> intervals. Try time steps of <span class="math notranslate nohighlight">\(\Delta t = 0.00075\)</span> and <span class="math notranslate nohighlight">\(\Delta t=0.005\)</span>.</p>
<p>Compare to the exact solution by graphing the results at <span class="math notranslate nohighlight">\(t=0.045\)</span>.</p>
</section>
<section id="solution-by-direct-matrix-multiplication">
<h3><span class="section-number">10.3.5. </span>Solution by Direct Matrix Multiplication<a class="headerlink" href="#solution-by-direct-matrix-multiplication" title="Link to this heading">#</a></h3>
<p>Modern computers are efficient at matrix manipulations. The number of operations for the solution of parabolic PDEs will be higher than what has been discussed in the previous sections, but nevertheless, for small problems, it should be efficient enough.</p>
<p>Let’s write down the form of the <span class="math notranslate nohighlight">\(\hat{H}\)</span> operator in the matrix representation. This is easy, since we know its action (up to a factor of <span class="math notranslate nohighlight">\(1/h^2\)</span>:</p>
<p><span class="math notranslate nohighlight">\((\hat{H}\phi)_i \propto \phi_{i+1} + \phi_{i-1} - 2\phi_i\)</span>.</p>
<p>E.g. for <span class="math notranslate nohighlight">\(i=1\)</span>:</p>
<p><span class="math notranslate nohighlight">\((\hat{H}\phi)_1 \propto \phi_{2} + \phi_{0} - 2\phi_1\)</span>,</p>
<p>for <span class="math notranslate nohighlight">\(i=2\)</span>:</p>
<p><span class="math notranslate nohighlight">\((\hat{H}\phi)_2 \propto \phi_{3} + \phi_{1} - 2\phi_2\)</span>,</p>
<p>for <span class="math notranslate nohighlight">\(i=N-1\)</span>:</p>
<p><span class="math notranslate nohighlight">\((\hat{H}\phi)_{N-1} \propto \phi_{N} + \phi_{N-2} - 2\phi_{N-1}\)</span>,</p>
<p>or in matrix form:</p>
<p><span class="math notranslate nohighlight">\(\hat{H} \propto \left(\begin{array}{cccccc} 
1 &amp; 0 &amp; ... &amp; 0 &amp; 0 &amp;  0\\
1 &amp; -2 &amp; 1 &amp; 0 &amp; 0 &amp; ... \\
0 &amp; 1 &amp; -2 &amp; 1 &amp; 0 &amp; ... \\ 
\ddots &amp; \ddots &amp;  \ddots &amp; \ddots &amp; \ddots &amp; \ddots \\
0 &amp; 0 &amp; ... &amp; 1 &amp; -2 &amp; 1 \\
0 &amp; 0 &amp; ... &amp; 0 &amp; 0 &amp;  1\\
\end{array}\right)\)</span>.</p>
<p>Therefore, to obtain a solution in the implicit scheme:</p>
<p><span class="math notranslate nohighlight">\(\phi^{n+1} = [1 + \hat{H} \Delta t]^{-1} \left[ \phi^n + S^n \Delta t \right]\)</span>,</p>
<p>with:</p>
<p><span class="math notranslate nohighlight">\((\hat{H}\phi)_i = -\frac{\phi_{i+1} + \phi_{i-1} - 2 \phi_i}{h^2}\)</span>,</p>
<p>all we need to do is find the inverse of the matrix operator:</p>
<p><span class="math notranslate nohighlight">\([1 + \hat{H} \Delta t]\)</span>.</p>
<p>Note that the inverse is calculated in NumPy via:</p>
<p><code class="docutils literal notranslate"><span class="pre">np.linalg.inv()</span></code></p>
<p>On the other hand, we can also use the <em>full</em> time evolution formula derived from the formal solution, via the matrix exponential.</p>
<p>Starting from the PDE:</p>
<p><span class="math notranslate nohighlight">\(\frac{\partial \phi(x,t)}{\partial t} = -\hat{H} \phi(x,t)\)</span>.</p>
<p>This can be formally solved to give:</p>
<p><span class="math notranslate nohighlight">\(\phi(x,t) = e^{-t\hat{H}} \phi(x,0)\)</span>,</p>
<p>which implies, in the discretized form, that:</p>
<p><span class="math notranslate nohighlight">\(\phi^n = e^{-n \Delta t \hat{H}} \phi^0\)</span>.</p>
<p>A single time step therefore corresponds to:</p>
<p><span class="math notranslate nohighlight">\(\phi^{n+1} = e^{-\Delta t \hat{H}} \phi^n\)</span>.</p>
<p>The matrix exponential can be calculated in SciPy (via a Padé approximant, see <a class="reference external" href="https://epubs.siam.org/doi/10.1137/09074721X">https://epubs.siam.org/doi/10.1137/09074721X</a>):</p>
<p><code class="docutils literal notranslate"><span class="pre">scipy.linalg.expm()</span></code>,</p>
<p>allowing us to perform the direct time step evolution in the simple case we are considering.</p>
<p>##3 Example 10.4: Direct inversion of the matrix and the full evolution</p>
<p>Use direct inversion of the tri-diagonal matrix to calculate the evolution in the problem of Examples 10.3 and 10.4.</p>
<p>(a) Use the implicit formula as the starting point:</p>
<p><span class="math notranslate nohighlight">\(\phi^{n+1} = \frac{1}{1 + \hat{H} \Delta t} \left[ \phi^n + S^n \Delta t \right]\)</span>,</p>
<p>with:</p>
<p><span class="math notranslate nohighlight">\((\hat{H}\phi)_i = -\frac{\phi_{i+1} + \phi_{i-1} - 2 \phi_i}{h^2}\)</span>.</p>
<p>(b) Use the <em>full</em> evolution formula:</p>
<p><span class="math notranslate nohighlight">\(\phi^n = e^{-n \Delta t \hat{H}} \phi^0\)</span>,</p>
<p>in the form:</p>
<p><span class="math notranslate nohighlight">\(\phi^{n+1} = e^{-\Delta t \hat{H}} \phi^n\)</span>.</p>
<p>You may use the matrix SciPy exponential:</p>
<p><code class="docutils literal notranslate"><span class="pre">scipy.linalg.expm</span></code></p>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./Chapters/Chapter10"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="../Chapter9/Chapter9.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">9. </span>Boundary Value and Eigenvalue Problems</p>
      </div>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#introduction">10.1. Introduction</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#elliptic-partial-differential-equations">10.2. Elliptic Partial Differential Equations</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#discretization">10.2.1. Discretization</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#variational-principle-approach">10.2.2. Variational Principle Approach</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#an-iterative-method-for-boundary-value-problems">10.2.3. An Iterative Method for Boundary Value Problems</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-10-1-the-relaxation-method-for-partial-differential-equations-in-one-dimension">10.2.4. Example 10.1: The relaxation method for partial differential equations in one dimension.</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-relaxation-method-in-higher-dimensions">10.2.5. The Relaxation Method in Higher Dimensions</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#parabolic-partial-differential-equations">10.3. Parabolic Partial Differential Equations</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#naive-discretization-and-instabilities">10.3.1. Naive Discretization and Instabilities</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-10-2-parabolic-pdes-a-first-example">10.3.2. Example 10.2: Parabolic PDEs: a first example</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#implicit-schemes">10.3.3. Implicit Schemes</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-10-3-application-of-the-implicit-scheme-for-parabolic-pdes">10.3.4. Example 10.3: Application of the Implicit Scheme for Parabolic PDEs</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#solution-by-direct-matrix-multiplication">10.3.5. Solution by Direct Matrix Multiplication</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Andreas Papaefstathiou
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>